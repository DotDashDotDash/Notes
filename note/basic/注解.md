# Java注解

## 注解有什么用

提供了一种在程序中关联任何信息和数据的方法

## 元数据

元数据从metadata一词译来，就是“关于数据的数据”的意思，即描述数据的结构信息。元数据的功能作用有很多，比如：你可能用过Javadoc的注释自动生成文档。这就是元数据功能的一种。总的来说，元数据可以用来创建文档，跟踪代码的依赖性，执行编译时格式检查，代替已有的配置文件。

在Java中元数据以标签的形式存在于Java代码中，元数据标签的存在并不影响程序代码的编译和执行，被用来生成其它的文件或只在运行时知道被运行代码的描述信息。

其作用如下:

* 生成文档：这是最常见的，也是java 最早提供的注解。常用的有@param @return 等

* 跟踪代码依赖性，实现替代配置文件功能。常见的是spring 2.5 开始的基于注解配置。作用就是减少配置。现在的框架基本都使用了这种配置来减少配置文件的数量

* 在编译时进行格式检查。如@override 放在方法前，如果你这个方法并不是覆盖了超类方法，则编译时就能检查出

## 元注解

元注解其他的都很简单，现在主要讨论@Interited注解，它表示该注解能够被继承

* 基于方法的注解继承性

```java
public class MyAnnotation {

    @Inherited
    @Retention(RetentionPolicy.RUNTIME)
    @Target({ElementType.METHOD, ElementType.FIELD})
    @interface A{
        String value() default "";
    }

    class Father{

        @A("father method a")
        public void a(){}

        @A("father method b")
        public void b(){}

        @A("father method c")
        public void c(){}
    }

    class Child extends Father{

        @Override
        public void a(){}
    }

    public void testAnnotationInheritance(){
        try {
            Method childMethodA = Child.class.getMethod("a");
            Method childMethodB = Child.class.getMethod("b");

            System.out.println(childMethodA.isAnnotationPresent(A.class));
            System.out.println(childMethodB.isAnnotationPresent(A.class));
        } catch (NoSuchMethodException e) {
            e.printStackTrace();
        }
    }

    public static void main(String[] args){
        MyAnnotation myAnnotation = new MyAnnotation();
        myAnnotation.testAnnotationInheritance();
    }
}
```

输出结果为

```java
false
true
```

可以看到父类的`a()`被重写后不再有注解`@A`，但是父类的`b()`的注解被继承到了子类`b()`中

* 基于类的注解继承性

```java
public class ClassInheritedTest {
    @Target(value = ElementType.TYPE)
    @Retention(value = RetentionPolicy.RUNTIME)
    @Inherited // 声明注解具有继承性
    @interface AInherited {
        String value() default "";
    }

    @Target(value = ElementType.TYPE)
    @Retention(value = RetentionPolicy.RUNTIME)
    @Inherited // 声明注解具有继承性
    @interface BInherited {
        String value() default "";
    }

    @Target(value = ElementType.TYPE)
    @Retention(value = RetentionPolicy.RUNTIME)
    // 未声明注解具有继承性
    @interface CInherited {
        String value() default "";
    }

    @AInherited("父类的AInherited")
    @BInherited("父类的BInherited")
    @CInherited("父类的CInherited")
    class SuperClass {
    }

    @BInherited("子类的BInherited")
    class ChildClass extends SuperClass {
    }

    public static void main(String[] args) {
        Annotation[] annotations = ChildClass.class.getAnnotations();
        System.out.println(Arrays.toString(annotations));
        // output: [@annotations.InheritedTest1$AInherited(value=父类的AInherited), @annotations.InheritedTest1$BInherited(value=子类的BInherited)]
    }
}

```

* 自定义注解 @CInherited 没有被@Inherited 修饰，不具备继承性，子类ChildClass获取类上的注解时，没有该注解；
* 自定义注解@BInherited，具备继承性，但是子类ChildClass在类上自行指定了与父类相同类型的注解@BInherited，那么子类获取其类注解时，@BInherited为子类自己声明的；
* 自定义注解@AInherited，具备继承性，子类上未指定相同注解，子类获取注解时，成功获取到父类上的@AInherited注解

* 基于接口的注解继承性

```java
public class IterInheritedTest {

    @Target(value = {ElementType.METHOD, ElementType.FIELD})
    @Retention(value = RetentionPolicy.RUNTIME)
    @interface DESC {
        String value() default "";
    }

    interface SuperInterface {
        @DESC("父接口的属性")
        String field = "field";
        @DESC("父接口方法foo")
        public void foo();
        @DESC("父接口方法bar")
        default public void bar() {

        }
    }

    interface ChildInterface extends SuperInterface {
        @DESC("子接口方法foo")
        @Override
        void foo();
    }

    class ChildClass implements SuperInterface {
        @DESC("子类的属性")
        public String field = "field";
        @Override
        public void foo() {
        }
    }

    public static void main(String[] args) throws NoSuchMethodException, NoSuchFieldException {
        Method iFoo = ChildInterface.class.getMethod("foo");
        System.out.println(Arrays.toString(iFoo.getAnnotations()));
        // output: [@annotations.IterInheritedTest$DESC(value=子接口方法foo)]

        Method iBar = ChildInterface.class.getMethod("bar");
        System.out.println(Arrays.toString(iBar.getAnnotations()));
        // output: [@annotations.IterInheritedTest$DESC(value=父接口方法bar)]

        Field iField = ChildInterface.class.getField("field");
        System.out.println(Arrays.toString(iField.getAnnotations()));
        // output: [@annotations.IterInheritedTest$DESC(value=父接口的属性)]

        Method foo = ChildClass.class.getMethod("foo");
        System.out.println(Arrays.toString(foo.getAnnotations()));
        // output: []; 被子类覆盖

        Method bar = ChildClass.class.getMethod("bar");
        System.out.println(Arrays.toString(bar.getAnnotations()));
        // output: [@annotations.IterInheritedTest$DESC(value=父接口方法bar)]

        Field field = ChildClass.class.getField("field");
        System.out.println(Arrays.toString(field.getAnnotations()));
        // output: [@annotations.IterInheritedTest$DESC(value=子类的属性)]
        // 是子类作用域下的属性`field`
    }
}
```

## 参考链接

* [Java注解的继承性](https://www.jianshu.com/p/a848655d478e)
* [Java注解](https://segmentfault.com/a/1190000019887623?utm_source=tag-newest)
* [全面解析Java注解](https://www.jianshu.com/p/efa3533e61e7)
