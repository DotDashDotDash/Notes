## 计算机组成原理相关知识

## 1. 思考题:

> ### 汇编板块

1. **所有的函数在调用的时候都需要栈帧吗?**

```markdown
不是所有的函数在调用的时候都需要栈帧，比如一些需要小于6个参数的函数并且局部变量完全可以用寄存器保存的函数就不需要栈帧
```

2. **寄存器组既然是通用的，如何保证不同的函数在调用的时候不会影响到其他函数的临时寄存器结果?**

```markdown
根据x86的管理，%rbp，%rbx和%r12~%r15被划分为被调用者保存寄存器，当过程P调用过程Q的时候，Q必须保存这些寄存器的值，
保证它们的值在P调用Q之前和Q返回P之后是一样的结果
```

> ### 中央处理器板块

1. **异常处理过程区别于过程调用有什么不同?**

```markdown
过程调用的时候，CPU将返回地址压入栈中，过程调用返回的时候，程序会自动从原来执行的位置开始执行。
异常处理的时候，CPU会根据异常的类型来决定程序是从原来的位置开始执行还是从原来指令的下一条指令开始执行。

过程调用运行在用户态
异常处理运行在内核态，并且拥有访问系统一切资源的权力

过程调用时，使用的栈是用户栈
异常处理的时候，使用的栈是内核栈
```

2. **异常的类别有哪些?**

```markdown
1. 中断(interrupt): 中断来自I/O设备的信号，中断是异步的，且总是返回到当前指令的下一条指令
2. 陷阱(trap): 用户发起的有意的异常，用于从用户态切换到内核态，陷阱是同步的，且总是返回到当前指令的下一条指令
3. 故障(fault): 潜在的可恢复的错误，故障是同步的，可能返回到当前指令，最典型的故障就是“缺页故障”
4. 终止(abort): 不可恢复的错误，终止是同步的，且不会返回

判断下列异常的类别:
1. 除法错误: 故障
2. 地址保护: 故障
3. 缺页: 故障
4. 机器检查: 终止
5. 操作系统定义的异常: 中断或陷阱
```

3. **CPU分为哪几个部分？分别实现了什么功能？**

```markdown
1. 运算器: 主要完成对数据的加工
	(1)算术逻辑单元ALU
	(2)通用寄存器组
	(3)暂存寄存器
	(4)程序状态字寄存器PSW
2. 控制器: 完成对计算机的指令控制，操作控制，时间控制，中断处理
	(1)存储器地址寄存器MAR
	(2)存储器数据寄存器MDR
	(3)指令寄存器IR
	(4)指令译码器ID
	(5)程序计数器PC
	(6)操作控制单元CU
```

4. **指令和数据均存放在内存当中，计算机如何从时间上和空间上区分他们是指令还是数据？**

```markdown
时间上：取指令事件发生在“取指周期”，取数据事件发生在“执行周期或指令译码周期”
空间上：从MM中取出的指令流向控制器中的IR，从MM中取出的数据流向运算器，因此CPU的控制器模块完成了对指令和数据的区分
```

5. **区分指令周期，取指周期，存取时间，存取周期，机器周期，时钟周期**

```markdown
1. 指令周期：FE,ID,EX,INT
2. 取指周期：从内存中读出一个指令字的最短时间
3. 存取时间：发起一次MM读/写及完成读/写的最短时间
4. 存取周期：连续完成两次读/写之间的最短时间间隔
5. 机器周期：执行指令周期当中一步相对完整的操作所用的时间，因为CPU速度比MM快，因此把机器周期一般设置为存取周期
6. 时钟周期：计算机基本的时序单位，通常是完成一个微操作所用的时间
```

6. **CPU硬布线控制器的微操作**

```markdown
1. 取指周期
T0: PC→MAR, 1→R
T1: M(MAR)→MDR，(PC+1)→PC
T2: MDR→IR, OP(IR)→ID, 1→IND

2. 间址周期
T0: Ad(MAR)→MAR, 1→R, 1→W
T1: M(MAR)→MDR
T2: MDR→Ad(IR), 1→EX

3. 执行周期
T0: Ad(IR)→MAR, 1→R
T1: M(MAR)→MDR
T2: //...之后的微操作

4. 中断周期，同样适用于转移指令
T0: (SP)-1→SP, SP→MAR
T1: PC→MDR, 1→W
T2: MDR→M(MAR)
T3: 中断向量→PC

//这里我总结了一下，凡是PC，MDR向别的寄存器传送内容，都不需要加括号
```

7. **CPU微程序控制器的微操作**

```markdown
1. 取指周期
T0: PC→MAR, 1→R
T1: Ad(CMDR)→CMAR
T2: M(MAR)→MDR, (PC)+1→PC
T3: Ad(CMDR)→CMAR
T4: MDR→IR
T5: OP(IR)→微地址形成部件→CMAR

//在取指周期，采用微程序控制器方式多了Ad(CMDR)→CMAR和OP(IR)→微地址形成部件→CMAR
//在执行周期，采用微程序控制器方式多了Ad(CMDR)→CMAR
```

8. **微程序控制器方式下，微地址是如何形成的**

```markdown
微程序控制器一共有3个部件影响微地址的形成，即顺序逻辑，CMAR，CMDR
1. 在取指阶段，OP(IR)经微地址形成部件形成初始微程序的地址，之后微地址的形成就不需要微地址形成部件了
2. 控制存储器CS通过CMAR取出对应地址的微指令，存放到CMDR当中
3. CMDR中的下地址字段被传送到顺序逻辑模块，注意，这里只是默认的下地址，还要经过顺序逻辑的判断，判断的条件来自于哪里？
   判断的条件来自于微指令的“判别测试”字段，通过“判断测试字段来判断程序是否需要进行转移，如果判断不通过或者不判断，下
   一条微指令的地址就是前面那个默认的CMDR中的下地址字段，否则还要加上相应的偏移量来形成最终的下地址字段
4. 重复过程2
```

9. **已知某计算机指令系统一共有n种操作，采用微程序控制器时，控制存储器CS中至少有多少微程序？**

```markdown
1. 所有计算机都有取指微程序，因此至少是n+1，一般情况下还有间址微程序
2. 若计算机带中断系统，那么有n+2个微程序
```

10. **微指令的编码**

```markdown
1. 直接编码：编码效率低，执行效率高
2. 字段直接编码：编码效率高，执行效率低
3. 互斥的微命令被编码在同一个字段，同时对于每一个互斥类，还要预留一个全0字段表示这个互斥类不操作
4. 在微指令的判断测试字段，同样还要有全0字段表示不进行判别测试
```

11. **区分不同的流水线类型**

```markdown
1. 部件级，处理机级和处理机间级
2. 单功能流水线和多功能流水线
	(1)单功能是指只能实现一种固定的专门功能的流水线
	(2)多功能是指通过各段之间的不同连接方式可以同时或者不同时实现多种功能的流水线
3. 动态流水线和静态流水线
	(1)静态流水线：同一时间内，流水线的各段只能按照同一种功能的连接方式工作
	(2)动态流水线：同一时间内，当某段正在进行某种运算，另外一些段正在进行另外一种运算
4. 线性流水线和非线性流水线
	(1)线性流水线：从输入到输出，每一个段只能经过一次且没有反馈
	(2)非线性流水线：某些功能段能进行多次的通过，适合递归运算
5. 超标量流水线：每个时钟周期可以并发执行多条指令，为此需要配置多个功能部件，不能调整指令执行的顺序，但是可以
   通过编译优化技术将多个可以并行的指令搭配起来
6. 超流水线：一个时钟周期内再分段，也不能调整指令执行的顺序，需要编译优化技术
7. 超长指令字：将多个可以并行的指令组合成一个超长的指令字
```

12. **流水线的各种冲突和冒险**

```markdown
1. 数据冒险：下条指令需要访问上一条指令未被写回的结果，引起数据冒险
	(1)硬件阻塞null和软件阻塞NOP推迟后序指令的执行
	(2)常考：设置数据旁路，不需要等待数据被写回WB，在EX阶段就被写回到寄存器中
	(3)编译优化，调整指令执行的顺序
2. 控制冲突：一条指令要确定下一条指令的位置，比如转移调用等因错误改变PC而导致流水线断流，引起控制冒险
	(1)对转移指令进行分支预测，尽快生成目标转移地址。
		a. 静态预测：预测条件总是不满足，继续执行分支指令的后序指令
		b. 动态预测：更具程序执行的历史情况，进行动态预测，有较高的预测准确率
	(2)把预测成功和预测不成功两个方向的指令都取了
	(3)加快形成条件码
	(4)提高转移方向的准确率(屁话)
```

13. **坑点：指令流水线中的ID与IF并行问题**

```markdown
1. 若题目没有特殊要求且观察程序之间的相互顺序没有很明显的先后顺序，IF段可以一个周期执行一次
↑
|
|		  IF--ID--EX--MM--WB
|     IF--ID--EX--MM--WB
├-IF--ID--EX--MM--WB
└------------------------------------→

2. 对于有流水线数据冒险的情况1而言，IF段可以不与ID段并行
↑
|
|		      IF--ID--EX--MM--WB
|     IF--ID--EX--MM--WB
├-IF--ID--EX--MM--WB
└------------------------------------→

3. 如果要求每条指令按序发射，按序接收，那么IF与ID段一定要并行
↑
|
|		            IF--ID--EX--MM--WB
|     IF------------ID--EX--MM--WB
├-IF--ID--EX--MM--WB
└------------------------------------→
```

> ### I/O板块

1. **I/O设备怎么与主机端进行通信？**

```markdown
I/O设备和主机的通信是通过I/O接口完成的，注意，I/O接口并不单单指是哪一个接口，而是一个模块，一个包含很多东西的
模块。I/O接口是夹在主机端和I/O设备之间的一个模块，包含:
1. 数据缓冲寄存器，其通过“数据线”与主机相连，数据线上传送的内容包括“CPU对外设的控制命令(流动方向为从CPU到外设)”
   I/O设备要送给CPU的数据等
2. 状态/控制寄存器，这是一个具有两种功能的寄存器，当数据的流动方向是从CPU传递过来的时候，它是控制寄存器，存储的
   是CPU对I/O设备的一些命令字数据。当数据的流动方向是流向CPU的时候，它是状态寄存器，表明外设的状态信息。
3. 地址译码和I/O逻辑，分别连接主机总线中的地址总线和控制总线，地址总线中的地址信息给出CPU要访问的I/O接口中的寄存
   器地址，而控制总线中的信息表明是对这些寄存器读或者写，此外，控制线上还会传递一些仲裁信号和握手信号。同时I/O逻辑
   还要完成对地址信息的译码工作。
4. 主机和I/O接口之间的通信是通过I/O总线(地址，数据，控制)，I/O接口和外设的通信是通过外设的寄存器  
5. 总结一些I/O接口的功能，即数据格式的转换，I/O过程中的错误和状态检测，I/O操作的定时和控制，与主机和外设之间的通信
```

2. **学会区分I/O接口与I/O端口**

```markdown
I/O接口是主机和外设通信的中间模块，而I/O端口指的是I/O接口中的寄存器
因此I/O指令实现的数据的传送通常发生在CPU的通用寄存器和I/O端口之间
```

3. **I/O指令的同一编址和独立编址**

```markdown
1. I/O指令在统一编址的情况下，I/O指令的地址采用的是内存地址，但是这种编址方式下，I/O指令的编址位置不能随意摆放，要么
   编址在高位，要么编址在低位，要么编址在一段固定的地址部分，因为统一编址的情况下，区分内存指令和I/O指令是通过地址码
   而不是地址线的方式，如果I/O指令随意摆放，那么无法通过地址码译码来区分
2. I/O指令在独立编址的情况下，CPU需要设置专门的I/O指令访问端口，访问这些端口也需要专门的I/O指令
```

4. **简要概括一下I/O系统**

```markdown
I/O系统包括I/O软件和I/O硬件：
1. I/O软件：包括驱动程序，用户程序，管理程序，升级补丁等。通常采用”I/O指令和通道指令”完成对CPU和I/O设备之间的通信
2. I/O硬件：包括外部设备，设备控制器，I/O总线等。

注意：I/O接口就是设备控制器！！！！！！！！！只不过叫法不同罢了
```

5. **简要概括一下外存储器**

```markdown
外存储器又称辅助存储器，目前主要使用磁表面存储器，例如：磁盘存储器，磁带存储器，磁鼓存储器。磁盘存储器又分为两个部分：
1. 磁盘驱动器：磁头组件和盘片组件，说白了就是构成磁盘的硬件。
2. 磁盘控制器：叫I/O接口也好，叫设备控制器也好。主流的标准有IDE, SCSI, SATA等

温彻斯特盘是一种磁头可动，盘片不动的硬盘存储器

除此之外还要会区分RAID0, 1, 2, 3, 4, 5，除了RAID0没有容错能力之外，其他的RAIDx都有容错能力，但是提高容错能力是以
减少实际可用存储容量的代价实现的

除了磁表面存储器之外还有光盘存储器，例如CD-ROM,CD-R,CD-RW,DVD-ROM
还有固态硬盘，主要发展自Flash，Flash的本质还是ROM
```

6. **区分“中断响应优先级”和“中断处理优先级”**

```markdown
中断响应优先级是由硬件排队线路或者中断查询程序的查询顺序决定的，不可以动态改变
中断处理优先级是通过中断屏蔽字来实现的，是动态的，可以改变的
```

7. **区分通道指令和I/O指令**

```markdown
不管I/O指令如何编址，都是CPU指令的一部分，而通道指令是只属于通道自己的指令
```

8. **区分字符设备和块设备**

```markdown
块设备和字符设备的最大区别就是块设备可以寻址，字符设备不能寻址，并且字符设备在I/O时采用中断驱动的方式
```

9. **通道程序放在哪？**

```markdown
通道程序存在主存当中，因此通道和CPU共享主存
```

10. **I/O子系统的层次**

```markdown
1. 用户层I/O软件：指用户发起I/O操作的地方
2. 设备独立性软件：用于实现用户程序和设备驱动器的统一接口，“设备命令”，“设备保护”和“设备分配与释放”，同时为设备管理和数据传送
   提供必要的存储空间
	(1) 将逻辑设备映射成物理设备
    (2) 对设备进行保护，禁止用户直接访问设备
    (3) 缓冲管理，差错控制
    (4) 提供独立于设备的大小同一的逻辑块
    (5) 屏蔽设备之间信息交换单位大小和传输速率的差异
    (6) 向用户层提供同一的read/write接口
3. 设备驱动程序
	(1) 每一类设备都有一个设备驱动程序，例如n种设备，有n种设备驱动程序
	(2) 设备驱动程序常常以进程的形式存在
	(3) 向上向用户层提供read/write标准接口，向下发送命令给设备控制器，控制I/O设备工作，同时也将设备控制器发来的信号传给上层
4. 中断处理程序
	(1) 保存被中断进程的CPU环境
	(2) 进程上下文的切换
	(3) 对处理中断信号源进行测试
5. 硬件设备
	(1) 设备控制器
	(2) I/O设备本身
```

11. **I/O缓冲**

```markdown
假设设备把缓冲区填满的时间为T，缓冲区向用户区传送整个缓冲区的时间为M，用户处理缓冲区数据的时间为C
1. 单缓冲模式下，处理一块数据的时间为 max(C,T)+M
	理解: 在M时间，缓冲区内容复制到用户区，用户处理数据，同时设备填充缓冲区，看谁先完成
2. 双缓冲模式下，处理一块数据的时间为 max(C+M,T)
	理解：在C+M时间内，一个缓冲区的内容被复制到用户区，同时设备向另一个缓冲区填数据，用时T，看是用户先处理完还是设备先填充完
```

12. **I/O设备分配的4张表**

```markdown
1. 设备控制表DCT
2. 控制器控制表COCT
3. 通道控制表CHCT
4. 系统设备表SDT
```

13. **I/O重定向使用的表**

```markdown
为了实现设备的独立性，在应用程序中使用“逻辑设备名”来请求使用某类设备，因此需要“设备逻辑表”，将逻辑设备名映射为物理设备名。
LUT的组成如下：

| 逻辑设备名 | 物理设备名 | 设备驱动程序入口地址 |

LUT既可以整个系统只设置一个LUT，也可以每个进程设置一个LUT(需要放置到PCB当中)
```

14. **区分输入井，输出井，输入缓冲区，输出缓冲区**

```markdown
1. 输入井和输出井是在磁盘上开辟的两个存储区域，用于模拟脱机时输入和输出的磁盘
2. 输入缓冲区和输出缓冲区是指在内存种开辟的两个缓冲区，用于接收和发送从设备来的数据
```

15. **I/O接口的分类**

```markdown
1. 有程序控制的I/O接口
2. 程序中断I/O接口
3. 直接存储器存取DMA接口
```



> ### 总线板块

1. **并行总线一定会比串行总线的传输速度快吗?**

```markdown
不是，并行总线虽然可以同时传送多个比特，但是需要多根数据线，在长距离的传输下，多根线会出现干扰，尤其是当数据传输速率
越高，这种干扰就会越发强烈，当数据传输率高到一定程度的时候，接收端接收到的信号就无法恢复，从而导致传输失败

因此在极限传输情况下，并行总线所能达到的极限传输速率远远不如串行总线
```

2. **单周期处理器可以采用单总线的数据通路吗？**

```markdown
若采用单总线结构，CPU也需要和其他挂载在总线上的设备争用总线，因此单周期处理器不能采用单总线数据通路
```

3. **区分链式查询，计数器定时查询，独立请求方式**

```markdown
链式查询的线数为3，分别为BS,BR,BG
计数器定时查询的线数为↑log2n↑+2，其中2分别为BS和BR，BG为译码模式
独立请求方式的线数为2n+1，1是BS，n是BR，n是BG
```

4. **总线标准**

```markdown
1. 系统总线
	(1) ISA(Industry Standard Architecture)，最早出现
	(2) EISA(Extended...) ISA的扩展
2. 局部总线
	(1) VESA，针对多媒体PC要求高速传送图像的大量数据
	(2) PCI，即插即用，针对高度集成的外部设备设计，与处理器时钟频率无关
	(3) AGP，专门连接主存和图形存储器
	(4) PCI-Express，取代PCI和AGP
3. 串行通信总线
	(1) RS-232C，数据通信设备和数据终端设备之间二进制数据交换的接口
	(2) USB，即插即用，连接外部设备的I/O总线
4. 接口标准
	(1) PCMCIA，笔记本电脑的接口标准
	(2) IDE，磁盘驱动器接口标准
	(3) SCSI，计算机和硬盘，光驱，软驱，打印机等智能设备之间的接口
	(4) SATA，标准的串行硬件驱动器接口
```

> ### 数据与运算板块

1. **IEEE754浮点数的总结**

| 值的类型       | 符号 | 阶码    | 尾数 | 值             |
| -------------- | ---- | ------- | ---- | -------------- |
| 正零           | 0    | 全0     | 全0  | 0              |
| 负零           | 1    | 全0     | 全0  | -0             |
| 正无穷大       | 0    | 全1     | 全0  | +∞             |
| 负无穷大       | 1    | 全1     | 全0  | -∞             |
| 无定义数       | 0或1 | 全1     | ≠0   | NaN            |
| 规格化非零正数 | 0    | (0,255) | f    | 1.f×2^(e-127)  |
| 规格化非零负数 | 1    | (0,255) | f    | -1.f×2^(e-127) |
| 非规格化正数   | 0    | 0       | f≠0  | 0.f×2^(-126)   |
| 非规格化负数   | 1    | 0       | f≠0  | -0.f×2^(-126)  |

2. **全0阶码非0尾数**

```markdown
在计算机中，全0阶码非0尾数表示的是非规格化数，非规格化数的作用是为了处理阶码下溢，当计算机出现比最小规格化数还小的数的时候
程序能够继续正常执行，例如在IEEE754浮点数标准当中，当出现2×2^{-133}这个数字的时候，因为阶码-133超过了IEEE规格化浮点数
阶码的最小值-126，因此会将原来的尾数左移，直到阶码变成-126，此时数字变成了非规格化的数字

注意，当阶码全0的时候，此时尾数的隐含位是0！！！！！！！（见上表）
```

3. **int, float, double, char之间的转换问题. i, f, d分别为int, float, double类型**

```markdown
1. i == (int) (float) i
解析：int精度比float高，因为int的31位都可以表示数字，但是float只有24位的精度，所以当int转float会造成精度丢失

2. f == (float) (int) f
解析：float有小数部分，当转化为int的时候，小数位可能会丢失，因此可能会丢失精度

3. i == (int) (double) i
解析：double有比int更大的精度表示范围，因此int转double不会丢失精度

4. f = (float) (double) f
解析：double有比float更大的精度表示范围，因此float转double不会造成精度丢失

5. d == (float) d
解析：double转float可能会丢失精度

6. f == -(-f)
解析：浮点数取反就是简单的符号位取反

7. f == (d + f) - d
解析：这个要特别注意，因为float和double类型的运算极有可能需要对阶，因此对阶过程中可能会出现下溢
```

