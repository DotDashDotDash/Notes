## 计算机组成原理相关知识

### 1. 汇编板块

首先先了解一下C语言的各个数据类型的相关知识:

<div align=center><img src=
 	"../assets/jz1.png"/>
</div>

x86-64的中央处理器CPU包含16个存储64位值的**通用寄存器**，这些寄存器可以用来存储数据和指针，16个寄存器如下:

<div align=center><img src=
    "../assets/jz2.png"/>
</div>

上面标了5个非常重要也是最常用的寄存器，分别是，**存储返回值的%eax，按照函数传递参数的顺序1234分别为%edi，%esi，%edx，%ecx，函数调用时保存当前调用点的栈指针%esp**

接下来是x86-64的操作数的格式:

<div align=center><img src=
    "../assets/jz3.png"/>
</div>

除了整数寄存器，CPU还维护者一组单个位的**条件码寄存器**，他们描述了最近的算术或者逻辑运算操作的**结果属性**，他们本保存在CPU运算器模块中的PSW中，作为执行条件分支指令的判断条件:

<div align=center><img src=
    "../assets/jz4.png"/>
</div>

**比较和测试指令不修改任何通用寄存器的值，只改变PSW中的条件码** 。常用的指令跳转的方式为，**首先利用cmp改变PSW，然后利用jxxx完成条件跳转**:

```c++
//c代码
int f(int n){
    if(n > 1)
        return n * f(n - 1);
    else
        return 2;
}

//汇编代码
int f(int n)
    00401000 55				push %ebp
    ...
    00401018 83 7D 08 01	cmp dword ptr [%ebp + 8], 1	//比较，执行n-1操作，此时会改变PSW
    													//例如SF, ZF
    0040101C 7E 17			jle f1+35	//jle说明跳转的条件是less and equal，即<=
    ...
    00401025 E8 D6 FF FF FF call f1	//递归调用
    ...
```

下面以传送指令为例，列举条件码影响分支转移的情况，着重看**传送条件的条件码组合!!!**:

<div align=center>
    <img src="../assets/jz5.png"/>
</div>

x86-64运行时的栈结构:

<div align=center>
    <img src="../assets/jz6.png"/>
</div>

* **当每一次函数调用的参数个数不超过6个时候，使用专门的寄存器来存储传递参数的值**

<div align=center>
    <img src="../assets/jz7.png"/>
</div>

* **当每一次函数调用的参数个数超过6个的时候，假设P函数调用了Q函数，Q函数的参数个数超过6个，那么就需要在P函数的栈帧中提前保存好这些参数的值**

## 思考题:

> ### 汇编板块

1. **所有的函数在调用的时候都需要栈帧吗?**

```markdown
不是所有的函数在调用的时候都需要栈帧，比如一些需要小于6个参数的函数并且局部变量完全可以用寄存器保存的函数就不需要栈帧
```

2. **寄存器组既然是通用的，如何保证不同的函数在调用的时候不会影响到其他函数的临时寄存器结果?**

```markdown
根据x86的管理，%rbp，%rbx和%r12~%r15被划分为被调用者保存寄存器，当过程P调用过程Q的时候，Q必须保存这些寄存器的值，
保证它们的值在P调用Q之前和Q返回P之后是一样的结果
```

> ### 中央处理器板块

1. **异常处理过程区别于过程调用有什么不同?**

```markdown
过程调用的时候，CPU将返回地址压入栈中，过程调用返回的时候，程序会自动从原来执行的位置开始执行。
异常处理的时候，CPU会根据异常的类型来决定程序是从原来的位置开始执行还是从原来指令的下一条指令开始执行。

过程调用运行在用户态
异常处理运行在内核态，并且拥有访问系统一切资源的权力

过程调用时，使用的栈是用户栈
异常处理的时候，使用的栈是内核栈
```

2. **异常的类别有哪些?**

```markdown
1. 中断(interrupt): 中断来自I/O设备的信号，中断是异步的，且总是返回到当前指令的下一条指令
2. 陷阱(trap): 用户发起的有意的异常，用于从用户态切换到内核态，陷阱是同步的，且总是返回到当前指令的下一条指令
3. 故障(fault): 潜在的可恢复的错误，故障是同步的，可能返回到当前指令，最典型的故障就是“缺页故障”
4. 终止(abort): 不可恢复的错误，终止是同步的，且不会返回

判断下列异常的类别:
1. 除法错误: 故障
2. 地址保护: 故障
3. 缺页: 故障
4. 机器检查: 终止
5. 操作系统定义的异常: 中断或陷阱
```

3. **CPU分为哪几个部分？分别实现了什么功能？**

```markdown
1. 运算器: 主要完成对数据的加工
	(1)算术逻辑单元ALU
	(2)通用寄存器组
	(3)暂存寄存器
	(4)程序状态字寄存器PSW
2. 控制器: 完成对计算机的指令控制，操作控制，时间控制，中断处理
	(1)存储器地址寄存器MAR
	(2)存储器数据寄存器MDR
	(3)指令寄存器IR
	(4)指令译码器ID
	(5)程序计数器PC
	(6)操作控制单元CU
```

4. **指令和数据均存放在内存当中，计算机如何从时间上和空间上区分他们是指令还是数据？**

```markdown
时间上：取指令事件发生在“取指周期”，取数据事件发生在“执行周期或指令译码周期”
空间上：从MM中取出的指令流向控制器中的IR，从MM中取出的数据流向运算器，因此CPU的控制器模块完成了对指令和数据的区分
```

5. **区分指令周期，取指周期，存取时间，存取周期，机器周期，时钟周期**

```markdown
1. 指令周期：FE,ID,EX,INT
2. 取指周期：从内存中读出一个指令字的最短时间
3. 存取时间：发起一次MM读/写及完成读/写的最短时间
4. 存取周期：连续完成两次读/写之间的最短时间间隔
5. 机器周期：执行指令周期当中一步相对完整的操作所用的时间，因为CPU速度比MM快，因此把机器周期一般设置为存取周期
6. 时钟周期：计算机基本的时序单位，通常是完成一个微操作所用的时间
```

6. **CPU硬布线控制器的微操作**

```markdown
1. 取指周期
T0: PC→MAR, 1→R
T1: M(MAR)→MDR，(PC+1)→PC
T2: MDR→IR, OP(IR)→ID, 1→IND

2. 间址周期
T0: Ad(MAR)→MAR, 1→R, 1→W
T1: M(MAR)→MDR
T2: MDR→Ad(IR), 1→EX

3. 执行周期
T0: Ad(IR)→MAR, 1→R
T1: M(MAR)→MDR
T2: //...之后的微操作

4. 中断周期，同样适用于转移指令
T0: (SP)-1→SP, SP→MAR
T1: PC→MDR, 1→W
T2: MDR→M(MAR)
T3: 中断向量→PC

//这里我总结了一下，凡是PC，MDR向别的寄存器传送内容，都不需要加括号
```

7. **CPU微程序控制器的微操作**

```markdown
1. 取指周期
T0: PC→MAR, 1→R
T1: Ad(CMDR)→CMAR
T2: M(MAR)→MDR, (PC)+1→PC
T3: Ad(CMDR)→CMAR
T4: MDR→IR
T5: OP(IR)→微地址形成部件→CMAR

//在取指周期，采用微程序控制器方式多了Ad(CMDR)→CMAR和OP(IR)→微地址形成部件→CMAR
//在执行周期，采用微程序控制器方式多了Ad(CMDR)→CMAR
```

8. **微程序控制器方式下，微地址是如何形成的**

```markdown
微程序控制器一共有3个部件影响微地址的形成，即顺序逻辑，CMAR，CMDR
1. 在取指阶段，OP(IR)经微地址形成部件形成初始微程序的地址，之后微地址的形成就不需要微地址形成部件了
2. 控制存储器CS通过CMAR取出对应地址的微指令，存放到CMDR当中
3. CMDR中的下地址字段被传送到顺序逻辑模块，注意，这里只是默认的下地址，还要经过顺序逻辑的判断，判断的条件来自于哪里？
   判断的条件来自于微指令的“判别测试”字段，通过“判断测试字段来判断程序是否需要进行转移，如果判断不通过或者不判断，下
   一条微指令的地址就是前面那个默认的CMDR中的下地址字段，否则还要加上相应的偏移量来形成最终的下地址字段
4. 重复过程2
```

9. **已知某计算机指令系统一共有n种操作，采用微程序控制器时，控制存储器CS中至少有多少微程序？**

```markdown
1. 所有计算机都有取指微程序，因此至少是n+1，一般情况下还有间址微程序
2. 若计算机带中断系统，那么有n+2个微程序
```

10. **微指令的编码**

```markdown
1. 直接编码：编码效率低，执行效率高
2. 字段直接编码：编码效率高，执行效率低
3. 互斥的微命令被编码在同一个字段，同时对于每一个互斥类，还要预留一个全0字段表示这个互斥类不操作
4. 在微指令的判断测试字段，同样还要有全0字段表示不进行判别测试
```





> ### 指令系统板块



