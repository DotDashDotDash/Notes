## 计算机组成原理相关知识

### 1. 汇编板块

首先先了解一下C语言的各个数据类型的相关知识:

<div align=center><img src=
 	"../assets/jz1.png"/>
</div>

x86-64的中央处理器CPU包含16个存储64位值的**通用寄存器**，这些寄存器可以用来存储数据和指针，16个寄存器如下:

<div align=center><img src=
    "../assets/jz2.png"/>
</div>

上面标了5个非常重要也是最常用的寄存器，分别是，**存储返回值的%eax，按照函数传递参数的顺序1234分别为%edi，%esi，%edx，%ecx，函数调用时保存当前调用点的栈指针%esp**

接下来是x86-64的操作数的格式:

<div align=center><img src=
    "../assets/jz3.png"/>
</div>

除了整数寄存器，CPU还维护者一组单个位的**条件码寄存器**，他们描述了最近的算术或者逻辑运算操作的**结果属性**，他们本保存在CPU运算器模块中的PSW中，作为执行条件分支指令的判断条件:

<div align=center><img src=
    "../assets/jz4.png"/>
</div>

**比较和测试指令不修改任何通用寄存器的值，只改变PSW中的条件码** 。常用的指令跳转的方式为，**首先利用cmp改变PSW，然后利用jxxx完成条件跳转**:

```c++
//c代码
int f(int n){
    if(n > 1)
        return n * f(n - 1);
    else
        return 2;
}

//汇编代码
int f(int n)
    00401000 55				push %ebp
    ...
    00401018 83 7D 08 01	cmp dword ptr [%ebp + 8], 1	//比较，执行n-1操作，此时会改变PSW
    													//例如SF, ZF
    0040101C 7E 17			jle f1+35	//jle说明跳转的条件是less and equal，即<=
    ...
    00401025 E8 D6 FF FF FF call f1	//递归调用
    ...
```

下面以传送指令为例，列举条件码影响分支转移的情况，着重看**传送条件的条件码组合!!!**:

<div align=center>
    <img src="../assets/jz5.png"/>
</div>

x86-64运行时的栈结构:

<div align=center>
    <img src="../assets/jz6.png"/>
</div>

* **当每一次函数调用的参数个数不超过6个时候，使用专门的寄存器来存储传递参数的值**

<div align=center>
    <img src="../assets/jz7.png"/>
</div>

* **当每一次函数调用的参数个数超过6个的时候，假设P函数调用了Q函数，Q函数的参数个数超过6个，那么就需要在P函数的栈帧中提前保存好这些参数的值**

## 思考题:

> ### 汇编板块

1. **所有的函数在调用的时候都需要栈帧吗?**

```markdown
不是所有的函数在调用的时候都需要栈帧，比如一些需要小于6个参数的函数并且局部变量完全可以用寄存器保存的函数就不需要栈帧
```

2. **寄存器组既然是通用的，如何保证不同的函数在调用的时候不会影响到其他函数的临时寄存器结果?**

```markdown
根据x86的管理，%rbp，%rbx和%r12~%r15被划分为被调用者保存寄存器，当过程P调用过程Q的时候，Q必须保存这些寄存器的值，
保证它们的值在P调用Q之前和Q返回P之后是一样的结果
```

> ### 中央处理器板块

1. 异常区别于过程调用有什么不同?

