## 从RocketMQ事务消息看性能优化

### 业务模型

本文中假定业务模型为A向B转账100元

在单机模型当中，将所有的操作都添加到一次事务当中，当事务执行的时候，性能损耗如下:

```markdown
  step1: 锁定A账户 (耗时: 1ms)
  step2: 锁定B账户 (耗时: 1ms)
  step3: 检查A账户是否有100元 (耗时: 2ms)
  step4: A账户减去100元 (耗时: 2ms)
  step5: B账户加上100元 (耗时: 2ms)
  step6: 解锁B账户 (耗时: 1ms)
  step7: 解锁A账户 (耗时: 1ms)
```

可以看到，上面的单机一体事务耗时10ms，但是随着业务的增加，A账户和B账户不是存储在同一个服务器上了，仍然将一次转账操作添加到一次事务当中，当事务执行的时候，性能损耗变成了:

```markdown
  step1: 锁定A账户 (耗时: 1ms)
  step2: 通过网络RPC锁定B账户 (耗时: (4+1)ms)
  step3: 检查A账户是否有100元 (耗时: 2ms)
  step4: A账户减去100元 (耗时: 2ms)
  step5: 通过网络RPC给B账户加上100元 (耗时: (4+2)ms)
  step6: 通过网络RPC解锁B账户 (耗时: (4+1)ms)
  step7: 解锁A账户 (耗时: 1ms)
```

然而当上面的事务执行完毕之后，性能消耗21ms，可以看到增加了很多，**这只是一次简单的转账操作的性能损耗的增加量！其他的复杂的业务逻辑在相同情况下耗时增加可想而知!!!**

### RocketMQ如何优化集群下的事务性能损耗

RocketMQ分布式事务消息采用了**大事务 = 小事务 + 异步**的模式，不仅可以实现应用之间的解耦，又能保证数据的最终一致性。同时，传统的大事务可以被拆分为小事务，不仅能提升效率，还不会因为某一个关联应用的不可用导致整体回滚，从而最大限度保证核心系统的可用性。在极端情况下，如果关联的某一个应用始终无法处理成功，也只需对当前应用进行补偿或数据订正处理，而无需对整体业务进行回滚。

<div align=center><img src="/assets/ro6.png"/></div>

### RocketMQ如何利用小事务+异步实现转账业务

RocketMQ实现转账业务大小分割的流程如下:

<div align=center><img src="/assets/ro7.png"/></div>

1. **Step1**: A账户所在机器发送一个Prepared消息到消息集群当中，同时会保留该Prepared消息的地址，以便在Step2对消息的状态进行修改，发送完消息之后A账户所在的事务会开始执行本地事务(包括锁定账户，检查，扣款)，**当本地的事务顺利执行完毕之后，A账户所在机器会根据原来保存的Prepared消息的地址在消息集群当中找到该消息，发送一个确认消息并完成Prepared消息状态的修改**
  * **问题1：如果A账户所在的机器发送Prepared消息失败了怎么办？** 如果这条消息发送失败，那么后续的消息也不会被发送，相当于这次转账操作从来没有进行过，此时客户可以认为网络不佳导致操作失灵，从而发起另外一次转账操作
  * **问题2：如果A账户所在的机器发送确认消息失败了怎么办？** RocketMQ会定期检查消息集群中的事务消息，如果发现了Prepared消息，会向生产者确认，此时到底是A账户扣款失败导致回滚还是继续发送确认消息，将会由消息生产者而定
2. **Step2**: B账户开始消费这条消息，此时会出现消费失败，消费超时和重复消费的问题，**解决消费失败和消费超时问题的对策就是一直重试，解决重复消费的问题的对策就是设置一张去重表，同样的消息绝不会重复消费第二次**