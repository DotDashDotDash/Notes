-------

### 目录



<!-- GFM-TOC -->

* [一、中央处理器](#一中央处理器)
* [二、存储系统](#二存储系统)
* [三、指令系统](#三指令系统)
* [四、I/O系统](#四io系统)
* [五、数据的表示与计算](#五数据的表示与计算)
* [六、总线](#六总线)
* [七、文件系统](#七文件系统)
* [番外篇：计算机系统的异常和中断](#番外篇计算机系统的异常和中断)
* [番外篇：408真题选择错题整理](#番外篇408真题选择错题整理)

<!-- GFM-TOC -->



# 一、中央处理器

1. **误区：什么是单周期CPU**

```markdown
单周期CPU是指一条指令的执行在一个周期内完成，而不是CPU的周期是一个固定的值
单周期CPU的CPI为1
```

2. **CPU分为哪几个部分？分别实现了什么功能？**

```markdown
1. 运算器: 主要完成对数据的加工
	(1)算术逻辑单元ALU
	(2)通用寄存器组
	(3)暂存寄存器
	(4)程序状态字寄存器PSW
	(5)累加寄存器ACC
	(6)计数器CT
2. 控制器: 完成对计算机的指令控制，操作控制，时间控制，中断处理
	(1)存储器地址寄存器MAR
	(2)存储器数据寄存器MDR
	(3)指令寄存器IR
	(4)指令译码器ID
	(5)程序计数器PC
	(6)操作控制单元CU
```

3. **程序状态字寄存器PSW和汇编中的条件转移**

```markdown
PSW是一个16位的寄存器，反映了CPU运算的状态特征并存放了某些控制标志。

CF: 进位标志位，当执行一个加法或者减法运算，最高位产生进位或者借位的时候，CF=1，否则CF=0
ZF: 零标志位，若当前运算的结果等于0，则ZF=1，否则ZF=0
SF: 符号标志位，该标志位与运算结果的最高位相同，即如果运算结果为“负”，SF=1，若运算结果为“正”，则SF=0
OF: 溢出标志位，若运算的结果超过机器能够表示的范围，则OF=1。OF=最高位进位(异或)次高位进位
PF: 奇偶标志位，当运算结果的最低16位含有偶数个1则PF=1
AF: 辅助进位标志位，一个加法(减法)的低4位向高4位有进位(或者借位)时AF=1否则AF=0
IF: 中断标志位，表示CPU是否可以响应可屏蔽中断
DF: 表示串处理指令的处理方向，DF=1表示串处理过程中地址自动递减，否则自动递增

下面重点对OF总结一下，OF=1的情况说明了数据运算发生了溢出，假设最高位(符号位)的进位为C1，次高位(最高数值位)的进位为C2
则OF=C1^C2,例如：

Example 1: 01111111B(+127)与0 0000001B(+1)相加，得10000000B(-128)
		  可以观察到，上述式子C1=0，C2=1, OF=C1^C2=1，说明发生了溢出
Example 2: 01111111B(+127)与10000001B(-127)相加，得000000000B(+0)
		  可以观察到，上述式子C1=1, C2=1，OF=C1^C2=0，说明没有发生溢出
Example 3: FFFFFFFFH(-1)与00000010H(+16相加)，得0000000FH
		  可以观察到，上述式子C1=1,C2=1，OF=C1^C2=0，说明没有发生溢出
		  
注意！计算机中两个数的相减虽然是采用补码相加的形式进行的运算，但是补码相加只是一个过程，减法运算的时候，只需要判断被减数
与减数哪一个大，直接得到借位标志！！！二进制判断太麻烦了，这是一种简便方法
```

4. **几个周期**

```markdown
1. 指令周期：FE,ID,EX,INT
2. 取指周期：从内存中读出一个指令字的最短时间
3. 存取时间：发起一次MM读/写及完成读/写的时间
4. 存取周期：连续完成两次读/写之间的“最短”时间间隔，也就是存取时间的最小值
5. 机器周期：执行指令周期当中一步相对完整的操作所用的时间，因为CPU速度比MM快，因此把机器周期一般设置为存取周期
6. 时钟周期：计算机基本的时序单位，通常是完成一个微操作所用的时间
```

5. **硬布线微程序控制器微指令编写汇总**

```markdown
1. 取指周期(通用)
	C1: (PC)→MAR				//有效控制信号: PCout, MARin
	C2: M(MAR)→MDR, (PC)+1→PC	//有效控制信号: MemR, MDRin, PC+1
	C3: (MDR)→IR				//有效控制信号: MDRout, IRin
	C4: 指令译码(也可以放在C3)	  //无有效控制信号

2. 加法: (R0)+((R1))→(R1)
	c1: (R1)→MAR				//有效控制信号: R1out, MARin
	C2: M(MAR)→MDR				//有效控制信号: MemR, MDRin
	C3: (MDR)→A					//有效控制信号: MDRout, Ain
	C4: (R0)+(A)→AC				//有效控制信号: ROout, Aout, ACin
	C5: (AC)→MDR				//有效控制信号: ACout, MDRin
	C6: (MDR)→M(MAR)			//有效控制信号: MDRout, MemW

3. 取数: LDA X: (X)→ACC
	C1: X→MAR(X可以是立即数，可以是寄存器)	//有效控制信号: MARin
	C2: M(MAR)→MDR				//有效控制信号: MemR, MDRin
	C3: (MDR)→ALU→ACC			//有效控制信号: MDRout, ALUin, ALUout, ACCin

4. 存数: STA X: (ACC)→(X)
	C1: X→MAR(X可以是立即数，可以是寄存器)	//有效控制信号: MARin
	C2: (ACC)→MDR				//有效控制信号: ACCout, MDRin
	C3: (MDR)→M(MAR)			//有效控制信号: MDRout, MemW

5. 立即数加法: ADD #a: (ACC)+a→ACC
	C1: Ad(IR)→R1				//有效控制信号: IRout, R1in
	C2: (ACC)+(R1)→R2			//有效控制信号: ACCout, R1out, R2in
	C3: (R2)→ACC				//有效控制信号: R2out, ACCin
	
6. 间址周期
	C1: Ad(IR)→MAR				//有效控制信号： IRout, MARin
	C2: M(MAR)→MDR				//有效控制信号： MemR, MDRin

7. 跳转指令: JMP K
	C1: (SP)-1→SP, (SP)→MAR		//有效控制信号: SP-1, SPout, MARin
	C2: (PC)→MDR				//有效控制信号: PCout, MDRin
	C3: (MDR)→M(MAR)			//有效控制信号: MDRout, MemW
	C4: Ad(IR)→MDR				//有效控制信号: IRout, MDRin
	C5: (MDR)→PC				//有效控制信号: MDRout, PCin

8. 中断处理:
	C1: 0→INT, 0→MAR			//有效控制信号: MARin
	C2: (PC)→MDR				//有效控制信号： PCout, MARin
	C3: (MDR)→M(MAR)			//有效控制信号： MDRout, MemW
	C4: 中断向量→PC				 //有效控制信号:	PCin
```

6. **若采用微程序控制器方式，则微指令比硬布线控制器多哪些微指令？**

```markdown
1. OP(IR)→CMAR		//首条微指令的地址
2. CM(CMAR)→CMDR	//将对应CM中的位于CMAR中的指令传送到CMDR中
3. Ad(CMDR)→CMAR	//当前微指令的顺序控制字段作为下一条微指令的地址
```

7. **微程序控制器方式下，微地址是如何形成的**

```markdown
微程序控制器一共有3个部件影响微地址的形成，即顺序逻辑，CMAR，CMDR
1. 在取指阶段，OP(IR)经微地址形成部件形成初始微程序的地址，之后微地址的形成就不需要微地址形成部件了
2. 控制存储器CS通过CMAR取出对应地址的微指令，存放到CMDR当中
3. CMDR中的下地址字段被传送到顺序逻辑模块，注意，这里只是默认的下地址，还要经过顺序逻辑的判断，判断的条件来自于哪里？
   判断的条件来自于微指令的“判别测试”字段，通过“判断测试字段来判断程序是否需要进行转移，如果判断不通过或者不判断，下
   一条微指令的地址就是前面那个默认的CMDR中的下地址字段，否则还要加上相应的偏移量来形成最终的下地址字段
4. 重复过程2
```

8. **已知某计算机指令系统一共有n种操作，采用微程序控制器时，控制存储器CS中至少有多少微程序？**

```markdown
1. 所有计算机都有取指微程序，因此至少是n+1，一般情况下还有间址微程序
2. 若计算机带中断系统，那么有n+2个微程序
```

9. **微指令的编码**

```markdown
1. 直接编码：编码效率低，执行效率高
2. 字段直接编码：编码效率高，执行效率低
	(1) 互斥的微命令被编码在同一个字段，同时对于每一个互斥类，还要预留一个全0字段表示这个互斥类不操作
	(2) 在微指令的判断测试字段，同样还要有全0字段表示不进行判别测试
3. 字段间接编码: 某些字段受其他字段的控制，这种编码方式降低了微指令的并行性
```

10. **控制存储器的容量**

```markdown
Example 1: 已知计算机有80条指令，每条指令由4条微指令组成，其中有一条微指令为取指微指令，是所有指令公用的，求CM容量
Solution: 由题知计算机共有3x80+1=241条微指令，而CM中的微指令条数是2的幂次方，因此CM容量为256x32位

Example 2: 已知计算机采用水平编码方式，有28条微指令，6个可互斥的外部判定条件，CM容量为512x40位，求微指令格式
Solution: 由题知微指令的字长为40位，下地址字段为(40-28-3)=6位，因此微指令的格式为28/3/9
注意：互斥条件的判定为编码的方式！！！！！！

Example 3: 已知计算机有52个控制信号，构成5个互斥的微命令组，各组分别包含5,8,2,15,22个微命令，已知可以外部判定的条件有2个，
		   微指令字长28位，求微指令格式
Solution: 由题知微指令字长为28位，因此各互斥组的位数为3,4,2,4,5,判定字段的位数为2，下地址字段为28-3-4-2-4-5-2=8
```

11. **流水线的分类**

```markdown
1. 部件级，处理机级和处理机间级
2. 单功能流水线和多功能流水线
	(1)单功能是指只能实现一种固定的专门功能的流水线
	(2)多功能是指通过各段之间的不同连接方式可以同时或者不同时实现多种功能的流水线
3. 动态流水线和静态流水线
	(1)静态流水线：同一时间内，流水线的各段只能按照同一种功能的连接方式工作
	(2)动态流水线：同一时间内，当某段正在进行某种运算，另外一些段正在进行另外一种运算
4. 线性流水线和非线性流水线
	(1)线性流水线：从输入到输出，每一个段只能经过一次且没有反馈
	(2)非线性流水线：某些功能段能进行多次的通过，适合递归运算
5. 超标量流水线：每个时钟周期可以并发执行多条指令，为此需要配置多个功能部件，不能调整指令执行的顺序，但是可以
   通过编译优化技术将多个可以并行的指令搭配起来
6. 超流水线：一个时钟周期内再分段，也不能调整指令执行的顺序，需要编译优化技术
7. 超长指令字：将多个可以并行的指令组合成一个超长的指令字
```

12. **流水线的各种冲突与冒险**

```markdown
1. 数据冒险：下条指令需要访问上一条指令未被写回的结果，引起数据冒险
	(1)硬件阻塞null和软件阻塞NOP推迟后序指令的执行
	(2)常考：设置数据旁路，不需要等待数据被写回WB，在EX阶段就被写回到寄存器中
	(3)编译优化，调整指令执行的顺序
2. 控制冲突：一条指令要确定下一条指令的位置，比如转移调用等因错误改变PC而导致流水线断流，引起控制冒险
	(1)对转移指令进行分支预测，尽快生成目标转移地址。
		a. 静态预测：预测条件总是不满足，继续执行分支指令的后序指令
		b. 动态预测：更具程序执行的历史情况，进行动态预测，有较高的预测准确率
	(2)把预测成功和预测不成功两个方向的指令都取了
	(3)加快形成条件码
	(4)提高转移方向的准确率(屁话)
```

13. **坑点：指令流水线中的ID与IF并行问题**

```markdown
1. 若题目没有特殊要求且观察程序之间的相互顺序没有很明显的先后顺序，IF段可以一个周期执行一次
↑
|
|		  IF--ID--EX--MM--WB
|     IF--ID--EX--MM--WB
├-IF--ID--EX--MM--WB
└------------------------------------→

2. 对于有流水线数据冒险的情况1而言，IF段可以不与ID段并行
↑
|
|             IF--ID--EX--MM--WB
|     IF--ID--EX--MM--WB
├-IF--ID--EX--MM--WB
└------------------------------------→

3. 如果要求每条指令按序发射，按序接收，那么IF与ID段一定要并行
↑
|
|                 IF--ID--EX--MM--WB
|     IF----------ID--EX--MM--WB
├-IF--ID--EX--MM--WB
└------------------------------------→
```

14. **什么是指令流水线的数据通路?**

```markdown
五阶段流水线可以分为取指IF，译码ID，执行EX，存储器读MEM，写回WB。数字系统中，各个子系统通过数据总线连接而成的数据传送
路径称为数据通路，包括PC,ALU,GRS,取指部件。数据通路不包含控制部件
```

15. **吐血整理，5段流水线各段的功能以及每段对应的什么操作**

```markdown
五段流水线顾名思义，就是ID,IF,EX,M,WB

1. IF: 以程序计数器PC中的内容放到MAR中，然后从存储器中取出相应的指令，同时PC加指令字长，指向下一条指令
2. ID: 对指令进行译码，并用IR中的Ad字段去访问通用寄存器组，读出所需的操作数(或者其他形式，例如立即数，这取决于寻址方式的不同)
3. EX: 执行/有效地址计算周期，对于不同的指令，所进行的操作是不一样的
	(1)Load/Store: ALU把指令中所指的寄存器与形式地址相加，得到访存的有效地址
	(2)除了Load/Store，其余的在EX段都是进行操作数的运算
	* 总结上面，Load/Store在这一段计算的是有效地址，而其他ALU运算，进行的是操作数的运算
	(3)分支指令: ALU将指令中的偏移量与PC相加，得到转移目标的地址
4. M: 存储器访问阶段: !!!!!!除了Load/Store还有分支指令，其他指令在这一个周期不做任何操作！！！！！！！！！！！！！！！！
	(1)Load: 根据EX段得到的有效地址计算出将要取得数据的地址，从存储器中取出数据
	(2)分支指令: 将计算的分支指令地址送入PC，到此，分支指令执行完成！！！！！！！！！！！！！
	(3)Store: 根据EX段得到的有效地址，写回到存储器，到此，Store指令执行完成!!!!!!!!
5. WB: ALU运算和Load把结果写回到通用寄存器组！！！！注意了，是写回到通用寄存器组！！！！！

总结一下：分支/Store在5段流水线中只占用4个周期，Load/其他指令占用5个周期!!!!!

Example: 已知下面顺序执行5条指令，要求按序发射，按序完成，请画出流水线的执行过程:

I1: LOAD R1, [a]	//M(a)→R1
I2: LOAD R2, [b]	//M(b)→R2
I3: SHL R1			//(R1)x2→R1
I4: ADD R1,R2		//(R1)+(R2)→R2
I5: STORE R2, [a]	//(R2)→M(a)

要点：
1. 按序发射，按序完成，故下一段指令IF和上一段指令ID段并行
2. 注意数据相关及各流水段的作用

解释： I1和I2都是取不互相干的数，因此互不干扰，正常执行。I3需要用到R1，R1为Load，需要等到WB结束，同理
I3需要等到I2的WB结束，I4需要等到I3的WB结束，I5需要等到I4的WB结束
```

|      | C1   | C2   | C3   | C4   | C5   | C6   | C7   | C8   | C9   | C10  | C11  | C12  | C13  | C14  | C15  | C16  | C17  |
| ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |
| I1   | IF   | ID   | EX   | ME   | WB   |      |      |      |      |      |      |      |      |      |      |      |      |
| I2   |      | IF   | ID   | EX   | ME   | WB   |      |      |      |      |      |      |      |      |      |      |      |
| I3   |      |      | IF   |      |      | ID   | EX   | ME   | WB   |      |      |      |      |      |      |      |      |
| I4   |      |      |      |      |      | IF   |      |      |      | ID   | EX   | ME   | WB   |      |      |      |      |
| I5   |      |      |      |      |      |      |      |      |      | IF   |      |      |      | ID   | EX   | ME   | WB   |



# 二、存储系统

1. **常见的串行访问存储器**

```markdown
串行访问存储器是对存储单元进行读写的时候，需要按照其物理位置的先后顺序寻址
串行访问存储器包括“顺序存取存储器(磁带)”和“直接存取存储器(磁盘)”
```

2. **顺序存取存储器和直接存取存储器以及RAM之间的区别**

```markdown
顺序存取存储器只能按照顺序存取
RAM可以按照随机访问任何一个单元
直接存取存储器介于两者之间，寻取信息的时候先寻找整个存储器的某个小区域(例如磁道)，再在小区域内部查找
```

3. **什么是相联存储器？**

```markdown
其基本原理是把存储单元所存内容的某一部分作为检索项去检索该存储器，并将存储器中与该检索项符合的存储单元内容读出或者写入
```

4. **操作系统程序保存在哪里？**

```markdown
操作系统程序保存在硬盘上，首先要先将其引导到RAM中，而引导程序通常放在ROM中
而程序运行时需要读写操作，因此应该采用RAM
```

5. **双端口RAM的读写冲突**

```markdown
双端口RAM并不是对同一个内存地址单元进行操作的时候都会发生冲突
1. A读取地址M，B写地址M，会冲突
2. A写地址M，B写地址M，会冲突
3. A读地址M，B读地址M，会冲突
```

6. **高位交叉编址和低位交叉编址谁更好的利用了局部性原理？**

```markdown
看起来高位交叉编址的存储器内容连续存放好像更加满足程序的局部性原理，但是其实是低位交叉编址更加满足！！！！！！
高位交叉编址并没有提高存储器的带宽，相反低位交叉编址虽然不连续，但是连续读取的带宽变大了，更像是为了满足程序局部性原理
而设计的产物
```

7. **有关低位交叉编址的误区！！！！**

```markdown
Pre: 假设一个四体低位交叉存储器，每个模块的容量是64K × 32位，存取周期为200ns，总线周期为50ns

说法：在50ns内，每个模块能向CPU提供32位信息？
分析：这种说法是错误的，是在200ns内，整个存储器能向CPU提供128位信息，但是每一个存储体仍然需要200ns才能向整个存储器提供32
	 位信息
```

8. **Cache写策略**

```markdown
1. Cache写命中的时候
	(1) 全写法：CPU将数据同时写回Cache和主存
	(2) 写回法：CPU只写入Cache不写入主存，等到换出Cache块的时候才写入主存，需要设置脏位
2. Cache写不命中的时候
	(1) 写分配法：加载主存中的块到Cache中，然后更新这个Cache，试图利用空间局部性，但是每一次不命中都要替换
	(2) 非写分配法：只写主存，不调块

非写分配法通常和全写法合用，写分配法通常和写回法合用
```

9. **加快地址转换的快表TLB**

```markdown
TLB是由高速缓冲存储器构成，其不是放在内存当中，而是放在专门的存储器
TLB的内容基本包含3个部分：Tag、Valid、实页号
```

10. **虚拟地址VA和物理地址PA之间的关系(重要)**

```markdown
//2018年王道真题
Q: 假设计算机按照字节编址，虚拟地址空间大小为16MB，物理地址大小为1MB，页面大小为4KB，Cache采用直接映射方式，共8行，主存
   和Cache之间交换的块大小为32B。判断虚拟地址位数，物理地址位数，虚页号位数，页框号位数，TLB中的tag位数，Cache中的Tag位数

1. 虚拟地址空间大小为16MB，因此虚拟地址位数为24位
2. 物理地址空间大小为1MB，因此物理地址位数为20位
3. 页面大小为4KB，即12位，因此VAP位数为24-12=12位，PAP位数为20-12=8位
4. PA为24位，页大小为4KB，因此TLB中的tag标记为共24-12=12位
5. PA的组成为：Tag,Index,Offset，其中块大小为32B，Offset共5位，直接映射共8行，Index共3位，故Tag=20-5-3=12位

补：若TLB还要组相联，还要从虚页号VAP中划分
```

11. **存取周期和存取时间**

```markdown
存取时间表示完成一次操作的时间，存取周期不仅包含操作时间还包含操作之后恢复线路的时间
存取周期=存取时间+恢复时间
```

12. **主存和Cache之间的调度是由硬件还是软件完成？**

```markdown
纯硬件
```

13. **关于数组存放的逻辑地址和物理地址**

```markdown
1. 数组的逻辑地址一定是连续的，数组的物理地址可能是不连续的，因为数组可能分布在不同的页当中
```

14. **磁盘的格式化问题**

```markdown
磁盘存储器在使用之前需要格式化，必须经过两步
1. 低级格式化(物理格式化)：将磁盘分为成扇区以便磁盘控制器能够读和写，同时为每个扇区采用特别的数据结构，包括校验码
2. 逻辑格式化：即创建文件系统，建立文件系统的根目录，对保存空闲磁盘块信息的数据结构进行初始化

低级格式化和逻辑格式化都提到了存储结构采用的数据结构，低级格式化是确定数据结构的格式，逻辑初始化是初始化这些逻辑结构
```

15. **有关磁盘容量，簇号和柱面号，磁道号，扇区号之间的转换问题**

```markdown
1. 磁盘容量=柱面数×磁道数×扇区数×每个扇区的大小
2. 柱面号=簇号/每个柱面的簇数
3. 磁头号=(簇号%每个柱面的簇数)/每个磁道的簇数
4. 扇区号=(簇号%每个磁道的扇区数)

例: 某计算机的磁盘有300个柱面，每个柱面有10个磁道，每个磁道有200个扇区，每个扇区有512B.文件系统的每个簇包含两个扇区，
请写出簇号，柱面号，扇区号，磁头号的转换关系
(1)一个柱面一共有10×200=2000个扇区，一个簇有2个扇区，故一个柱面有1000个簇，柱面号=簇号/每个柱面的簇数=簇号/1000
(2)一个磁道有200个扇区，所以一个磁道有100个簇，磁头号=(簇号%每个柱面的簇数)/每个磁道的簇数=(簇号%1000)/100
(3)	一个簇有2个扇区，类似的0，1号扇区归属为0号簇，2，3号扇区归属为1号簇，扇区号=((簇号%每个柱面的簇数)×2)%每个磁道的扇区数

将簇号转为磁盘物理地址的过程由“磁盘驱动程序”完成
```

16. **用户源程序到内存中可执行程序的过程**

```markdown
1. 编译：将用户源代码编译成若干目标模块
2. 链接：将目标模块与所需的库函数链接在一起，形成完整的装入模块
3. 装入：将装入模块装入到内存中运行

(1) 在链接阶段
	a. 静态链接：程序运行之前，就链接成一个完整的模块，之后不再分开
	b. 装入时动态链接：装入内存时，边装入边链接
	c. 运行时动态链接：程序需要执行该目标模块时才链接。便于修改和更新，实现对目标模块的共享
(2) 在装入阶段
	a. 绝对装入：在“编译”时就知道程序将驻留内存的某个区域，“编译程序产生绝对地址的目标代码”，程序的逻辑地址与物理地址完全
	   相同
	b. 静态重定位装入：一个作业的地址由逻辑地址加上这个作业的起始地址，作业在装入的时候，必须分配它要求的全部内存空间，若没有
	   足够的内存，则不能装入这个作业。此外作业一旦进入内存，整个运行期间就不能在内存中移动，也不能再申请内存空间
	c. 动态重定位装入：程序装入内存时并不进行地址转换，而当运行时才进行地址转换，而且程序不需要被分配到连续的内存之中，还可以
	   根据需要动态申请分配内存。“这种方式需要一个重定位寄存器”
```

17. **分段存储管理如何实现段的共享和保护？**

```markdown
1. 段的共享
	(1) 段的共享是通过两个作业的段表中相应的表项指向被共享的段的一个物理副本实现的
	(2) 若进程P1和P2共享段S，那么下列说法中错误的是:
		a. P1和P2在物理内存中仅保留一份段S的内容(√)
		b. 段S在P1和P2中应该有相同的段号(×)
			解析：段S在P1和P2中的使用位置可能不同，因此逻辑段号可能不同，但是段表中的物理段号是唯一的
		c. P1和P2共享段S在段表中的段表项(√)
		d. P1和P2都不再使用段S时才会回收段S所占的内存空间(√)
```



# 四、I/O系统

1. **I/O设备怎么与主机端进行通信？**

```markdown
I/O设备和主机的通信是通过I/O接口完成的，注意，I/O接口并不单单指是哪一个接口，而是一个模块，一个包含很多东西的
模块。I/O接口是夹在主机端和I/O设备之间的一个模块，包含:
1. 数据缓冲寄存器，其通过“数据线”与主机相连，数据线上传送的内容包括“CPU对外设的控制命令(流动方向为从CPU到外设)”
   I/O设备要送给CPU的数据等
2. 状态/控制寄存器，这是一个具有两种功能的寄存器，当数据的流动方向是从CPU传递过来的时候，它是控制寄存器，存储的
   是CPU对I/O设备的一些命令字数据。当数据的流动方向是流向CPU的时候，它是状态寄存器，表明外设的状态信息。
3. 地址译码和I/O逻辑，分别连接主机总线中的地址总线和控制总线，地址总线中的地址信息给出CPU要访问的I/O接口中的寄存
   器地址，而控制总线中的信息表明是对这些寄存器读或者写，此外，控制线上还会传递一些仲裁信号和握手信号。同时I/O逻辑
   还要完成对地址信息的译码工作。
4. 主机和I/O接口之间的通信是通过I/O总线(地址，数据，控制)，I/O接口和外设的通信是通过外设的寄存器  
5. 总结一些I/O接口的功能，即数据格式的转换，I/O过程中的错误和状态检测，I/O操作的定时和控制，与主机和外设之间的通信
```

2. **学会区分I/O接口与I/O端口**

```markdown
I/O接口是主机和外设通信的中间模块，而I/O端口指的是I/O接口中的寄存器
因此I/O指令实现的数据的传送通常发生在CPU的通用寄存器和I/O端口之间
```

3. **I/O指令的同一编址和独立编址**

```markdown
1. I/O指令在统一编址的情况下，I/O指令的地址采用的是内存地址，但是这种编址方式下，I/O指令的编址位置不能随意摆放，要么
   编址在高位，要么编址在低位，要么编址在一段固定的地址部分，因为统一编址的情况下，区分内存指令和I/O指令是通过地址码
   而不是地址线的方式，如果I/O指令随意摆放，那么无法通过地址码译码来区分
2. I/O指令在独立编址的情况下，CPU需要设置专门的I/O指令访问端口，访问这些端口也需要专门的I/O指令
```

4. **简要概括一下I/O系统**

```markdown
I/O系统包括I/O软件和I/O硬件：
1. I/O软件：包括驱动程序，用户程序，管理程序，升级补丁等。通常采用”I/O指令和通道指令”完成对CPU和I/O设备之间的通信
2. I/O硬件：包括外部设备，设备控制器，I/O总线等。

注意：I/O接口就是设备控制器！！！！！！！！！只不过叫法不同罢了
```

5. **区分通道指令和I/O指令**

```markdown
不管I/O指令如何编址，都是CPU指令的一部分，而通道指令是只属于通道自己的指令
```

6. **区分字符设备和块设备**

```markdown
块设备和字符设备的最大区别就是块设备可以寻址，字符设备不能寻址，并且字符设备在I/O时采用中断驱动的方式
```

7. **通道程序放在哪？**

```markdown
通道程序存在主存当中，因此通道和CPU共享主存
```

8. **I/O子系统的层次**

```markdown
1. 用户层I/O软件：指用户发起I/O操作的地方
2. 设备独立性软件：用于实现用户程序和设备驱动器的统一接口，“设备命令”，“设备保护”和“设备分配与释放”，同时为设备管理和数据传送
   提供必要的存储空间
	(1) 将逻辑设备映射成物理设备
    (2) 对设备进行保护，禁止用户直接访问设备
    (3) 缓冲管理，差错控制
    (4) 提供独立于设备的大小同一的逻辑块
    (5) 屏蔽设备之间信息交换单位大小和传输速率的差异
    (6) 向用户层提供同一的read/write接口
3. 设备驱动程序
	(1) 每一类设备都有一个设备驱动程序，例如n种设备，有n种设备驱动程序
	(2) 设备驱动程序常常以进程的形式存在
	(3) 向上向用户层提供read/write标准接口，向下发送命令给设备控制器，控制I/O设备工作，同时也将设备控制器发来的信号传给上层
4. 中断处理程序
	(1) 保存被中断进程的CPU环境
	(2) 进程上下文的切换
	(3) 对处理中断信号源进行测试
5. 硬件设备
	(1) 设备控制器
	(2) I/O设备本身
```

9. **I/O缓冲**

```markdown
假设设备把缓冲区填满的时间为T，缓冲区向用户区传送整个缓冲区的时间为M，用户处理缓冲区数据的时间为C
1. 单缓冲模式下，处理一块数据的时间为 max(C,T)+M
	理解: 在M时间，缓冲区内容复制到用户区，用户处理数据，同时设备填充缓冲区，看谁先完成
2. 双缓冲模式下，处理一块数据的时间为 max(C+M,T)
	理解：在C+M时间内，一个缓冲区的内容被复制到用户区，同时设备向另一个缓冲区填数据，用时T，看是用户先处理完还是设备先填充完
```

10. **I/O设备分配的4张表**

```markdown
1. 设备控制表DCT
2. 控制器控制表COCT
3. 通道控制表CHCT
4. 系统设备表SDT
```

11. **I/O重定向使用的表**

```markdown
为了实现设备的独立性，在应用程序中使用“逻辑设备名”来请求使用某类设备，因此需要“设备逻辑表”，将逻辑设备名映射为物理设备名。
LUT的组成如下：

| 逻辑设备名 | 物理设备名 | 设备驱动程序入口地址 |

LUT既可以整个系统只设置一个LUT，也可以每个进程设置一个LUT(需要放置到PCB当中)
```

12. **区分输入井，输出井，输入缓冲区，输出缓冲区**

```markdown
1. 输入井和输出井是在磁盘上开辟的两个存储区域，用于模拟脱机时输入和输出的磁盘
2. 输入缓冲区和输出缓冲区是指在内存种开辟的两个缓冲区，用于接收和发送从设备来的数据
```

13. **I/O接口的分类**

```markdown
1. 有程序控制的I/O接口
2. 程序中断I/O接口
3. 直接存储器存取DMA接口
```

14. **DMA和CPU请求总线的优先级谁大？**

```markdown
DMA的优先级大，因为如果DMA的请求没有得到及时的响应那么DMA中的I/O数据可能会丢失
```

15. **通道，设备控制器，设备之间的关系**

```markdown
通道控制设备控制器，设备控制器控制设备
```

16. **有关DMA的误区**

```markdown
1. 假如DMA需要传送3200B数据，然而DMA单次只能传送32B，则需要分100次传送，然而只有3200B数据全部都传送完成的时候，才会发出中断
2. DMA传送过程中虽然不占用CPU的任何资源，但是DMA需要占用总线来传送数据
3. 若DMA全部数据没有传送完成，CPU仍然可以访问主存，因为DMA采取周期挪用的方式访问主存的时候，访问主存的操作存在间隔，故CPU可以
	在DMA不使用主存的时候访问主存
4. 一个DMA只能控制一台设备与内存交换数据，而一个通道可以控制多台设备与内存交换数据
```





# 五、数据的表示与计算

1. **在进行n位的整数乘法时，假设乘法的结果为2n位，判断在imul和mul情况下乘法结果是否发生溢出？**

```markdown
1. 在mul情况下，如果高n位均为0，则乘法结果没有发生溢出
2. 在imul情况下，如果高n位是低n位的符号扩展，则没有发生溢出，即高n+1位全0或者全1的时候，乘法结果没有发生溢出
```

2. **定点数要进行×2运算，可以通过移位shl进行，那么浮点数呢？可以通过shl进行×2吗？**

```markdown
不行，因为浮点数的组成为(符号位，阶码位，尾数位)，单纯的shl也会造成阶码x2，其实这样是不对的
因为浮点数尾数x2的时候，阶码需要+1而不是x2，因此浮点运算不能使用shl
```

3. **在使用相对寻址计算跳转指令地址的时候，PC的值是unsigned而offset是补码，如何计算得到跳转后的指令地址？**

```markdown
假设PC中的内容是0x00487256,指令中的offset为0xffff(补码-1)
首先将offset符号扩展为32位，即0xffffffff
其次计算：0x00487256 + 0xffffffff = 0x00487255(补)
即得到正确的跳转地址
```

4. **int, float, double, char之间的转换问题. i, f, d分别为int, float, double类型**

```markdown
1. i == (int) (float) i
解析：int精度比float高，因为int的31位都可以表示数字，但是float只有24位的精度，所以当int转float会造成精度丢失

2. f == (float) (int) f
解析：float有小数部分，当转化为int的时候，小数位可能会丢失，因此可能会丢失精度

3. i == (int) (double) i
解析：double有比int更大的精度表示范围，因此int转double不会丢失精度

4. f = (float) (double) f
解析：double有比float更大的精度表示范围，因此float转double不会造成精度丢失

5. d == (float) d
解析：double转float可能会丢失精度

6. f == -(-f)
解析：浮点数取反就是简单的符号位取反

7. f == (d + f) - d
解析：这个要特别注意，因为float和double类型的运算极有可能需要对阶，因此对阶过程中可能会出现下溢
```

5. **IEEE754浮点数的总结**

| 值的类型       | 符号 | 阶码    | 尾数 | 值             |
| -------------- | ---- | ------- | ---- | -------------- |
| 正零           | 0    | 全0     | 全0  | 0              |
| 负零           | 1    | 全0     | 全0  | -0             |
| 正无穷大       | 0    | 全1     | 全0  | +∞             |
| 负无穷大       | 1    | 全1     | 全0  | -∞             |
| 无定义数       | 0或1 | 全1     | ≠0   | NaN            |
| 规格化非零正数 | 0    | (0,255) | f    | 1.f×2^(e-127)  |
| 规格化非零负数 | 1    | (0,255) | f    | -1.f×2^(e-127) |
| 非规格化正数   | 0    | 0       | f≠0  | 0.f×2^(-126)   |
| 非规格化负数   | 1    | 0       | f≠0  | -0.f×2^(-126)  |

6. **全0阶码非0尾数**

```markdown
在计算机中，全0阶码非0尾数表示的是非规格化数，非规格化数的作用是为了处理阶码下溢，当计算机出现比最小规格化数还小的数的时候
程序能够继续正常执行，例如在IEEE754浮点数标准当中，当出现2×2^{-133}这个数字的时候，因为阶码-133超过了IEEE规格化浮点数
阶码的最小值-126，因此会将原来的尾数左移，直到阶码变成-126，此时数字变成了非规格化的数字

注意，当阶码全0的时候，此时尾数的隐含位是0！！！！！！！（见上表）
```

7. **关于计算机实现乘法指令**

```markdown
1. 乘法指令可以用加法和移位来实现，如果计算机中没有专门的乘法指令，可以通过自己编写程序通过循环控制加法和移位计算
2. 对于程序实现的乘法指令，每一步都需要取指，译码，执行，写回，计算时间很长
3. 阵列乘法器只需要在一个时钟周期内就能计算出乘法的结果
```



# 六、总线

1. **并行总线一定会比串行总线的传输速度快吗?**

```markdown
不是，并行总线虽然可以同时传送多个比特，但是需要多根数据线，在长距离的传输下，多根线会出现干扰，尤其是当数据传输速率
越高，这种干扰就会越发强烈，当数据传输率高到一定程度的时候，接收端接收到的信号就无法恢复，从而导致传输失败

因此在极限传输情况下，并行总线所能达到的极限传输速率远远不如串行总线
```

2. **单周期处理器可以采用单总线的数据通路吗？**

```markdown
若采用单总线结构，CPU也需要和其他挂载在总线上的设备争用总线，因此单周期处理器不能采用单总线数据通路
```

3. **区分链式查询，计数器定时查询，独立请求方式**

```markdown
链式查询的线数为3，分别为BS,BR,BG
计数器定时查询的线数为↑log2n↑+2，其中2分别为BS和BR，BG为译码模式
独立请求方式的线数为2n+1，1是BS，n是BR，n是BG
```

4. **总线标准**

```markdown
1. 系统总线
	(1) ISA(Industry Standard Architecture)，最早出现
	(2) EISA(Extended...) ISA的扩展
2. 局部总线
	(1) VESA，针对多媒体PC要求高速传送图像的大量数据
	(2) PCI，即插即用，针对高度集成的外部设备设计，与处理器时钟频率无关
	(3) AGP，专门连接主存和图形存储器
	(4) PCI-Express，取代PCI和AGP
3. 串行通信总线
	(1) RS-232C，数据通信设备和数据终端设备之间二进制数据交换的接口
	(2) USB，即插即用，连接外部设备的I/O总线
4. 接口标准
	(1) PCMCIA，笔记本电脑的接口标准
	(2) IDE，磁盘驱动器接口标准
	(3) SCSI，计算机和硬盘，光驱，软驱，打印机等智能设备之间的接口
	(4) SATA，标准的串行硬件驱动器接口
```



# 七、文件系统

1. **有关对文件执行open操作**

```markdown
1. 每个进程的PCB中都保存着一张“文件描述符表”，每个文件对应的描述符就是这个表的索引，“文件描述符表”中的每一个表项都指向一个
已经打开的文件的指针，当文件首次被打开的时候，会增加打开文件的表项，以后的多次打开只会让文件打开的计数值增加
2. 当一个文件被当前进程首次打开的时候，OS会将文件的控制块FCB从外存调入到内存(并不会将文件的内容调入到内存当中)，只有当当前
进程真正想获取文件内容的时候才会将文件内容复制到内存当中
3. 对于同一个文件的打开，不同的进程在各自对应的“文件打开表”中分别有对应的一项
```

2. **文件read系统调用应该传递的参数**

```markdown
1. 文件描述符
2. 读取到的文件内容的目标buffer缓冲首址
3. 需要读取的文件的长度
```

3. **FCB包含哪些内容**

```markdown
1. 文件名
2. 文件类型: 目录/普通文件/音频文件/etc
3. 文件的存取权限: read/write/etc
4. 文件的外存物理地址: 外存块号
5. 其他
```

4. **有关文件的逻辑地址和物理地址**

```markdown
对文件的访问实际上就是对虚拟存储空间的访问，因此用户直接操作的是逻辑地址，逻辑地址到物理地址的转换由OS完成
```

5. **有关磁盘的FAT表**

```markdown
1. 一个磁盘只有一个FAT表，FAT表初始时刻是在磁盘当中的
2. 当计算机开机的时候，FAT会从磁盘读取到内存当中
```

6. **误区！！！！显式链接分配支持随机访问**

```markdown
在隐式链接分配当中，当想要访问文件的第i个块的时候，需要依次访问文件的i-1个块，因为第i个块的位置在第i-1个块的末尾
在显示链接分配当中，因为FAT表的加入，得到第i块的位置，只需要查看i-1次FAT表，不需要依次读取磁盘，因此支持随机访问
```

7. **区分外部碎片和内部碎片**

```markdown
1. 外部碎片是指整个磁盘块，有某些“块”无法被利用，称为外部碎片
2. 内部碎片是指一个磁盘块没有被使用完，称为内部碎片
```

8. **成组链接法**

```markdown
整个磁盘会分散着存在着很多连续不一的磁盘块，成组链接法的思想就是“把每一片连续的磁盘块分成一组”，假设一个磁盘块分为n+1个表项
1. 1~n个表项存储连续的n个空闲块
2. 第n+1个表项存储的是“下一个连续的n个磁盘块的索引表”
```

9. **索引表和文件之间的关系**

```markdown
一个文件只有一个索引表!!!
所以文件最大的长度建立在一个索引表能表示多少磁盘块
```



# 番外篇：计算机系统的异常和中断

1. **计算机异常的类型有哪些?**

```markdown
1. 陷阱/内中断(trap): 用户发起的有意的异常，用于从用户态切换到内核态，陷阱是同步的，且总是返回到当前指令的下一条指令
2. 故障(fault): 潜在的可恢复的错误，故障是同步的，可能返回到当前指令，最典型的故障就是“缺页故障”
3. 终止(abort): 不可恢复的错误，终止是同步的，且不会返回
4. 外中断(interrupt): 外中断来自I/O设备的信号，外中断是异步的，且总是返回到当前指令的下一条指令

判断下列异常的类别:
1. 除法错误: 故障(内部异常)
2. 地址保护: 故障(内部异常)
3. 缺页: 故障，这里要着重注意，缺页属于异常(内部异常)，并非外中断！！！！
	说法：缺页属于中断(X)
4. 机器检查: 终止
5. 算术溢出：故障(内部异常)
6. 地址越界：故障(内部异常)

在王道中讲的不太好，其实外中断也属于异常，但是王道中所说的异常一般是“来自于CPU内部”的异常，注意区分即可
```

2. **有关定时器中断，他娘的被这个搞死了，每次都错**

```markdown
定时器中断/时钟中断的目的是处理与时间有关的信息以及决定是否执行调度程序，其中和时间有关的信息是指和时间有关的所有信息！！！
时钟中断服务程序完成的功能如下：
(1)更新系统时间
(2)更新当前进程的时间片
(3)更新延时时间
(4)更新当前进程使用CPU的时间
(5)更新各种定时器的值
一般来说，只要看到与时间有关的，全给他选咯
```

3. **非屏蔽中断和可屏蔽中断，硬件中断和软件中断**

```markdown
1. 非屏蔽中断和可屏蔽中断都是外部中断，都属于硬件中断(记住咯铁汁，外部中断就是硬件中断)，都来自于外部！！！
	(1)常见的非屏蔽中断有：电源掉电，必须处理，不能屏蔽
	(2)常见的屏蔽中断有：I/O设备请求的中断
2. 外部中断都是硬件中断，内部中断是通过指令产生的中断，属于软件中断
```

4. **中断响应优先级和中断处理优先级**

```markdown
1. 中断响应优先级是通过硬件排队线路或者中断查询程序顺序决定的，不可改变，简单的说就是“所有中断请求根据优先级排队来决定谁先被响应”
2. 中断处理优先级时通过“中断屏蔽字”来改变的，可以改变中断返回时的顺序

简单的说，中断响应优先级无法被改变，中断处理优先级可以被改变
```

5. **单级中断系统与多级嵌套中断系统的中断处理流程**

```markdown
1. 单级								
(1)关中断                              
(2)保存断点	                           
(3)引出中断服务子程序                    
(4)保存现场                      
(5)执行中断服务程序                      
(6)恢复现场                      
(7)开中断                              
(8)中断返回                            
                                      
2. 多级                                      
(1)关中断
(2)保存断点
(3)引出中断服务子程序
(4)保存现场和屏蔽字
(5)开中断
(6)执行中断服务程序	//中间允许中断嵌套
(7)关中断
(8)恢复现场和屏蔽字
(9)开中断
(10)中断返回
```

6. **中断会导致进程切换吗**

```markdown
1. 中断会导致进程切换
2. 进程切换是指从运行的进程之中去回收CPU，让待运行的进程去使用CPU
3. 进程切换一定发生在中断，异常，系统调用的过程中。例如常说的缺页中断就是原进程与缺页中断处理进程之间的切换
4. 进程切换的工作流程:
	(1)保存被中断的进程的现场信息，即保存当前的PC和PSW到SP中
	(2)将当前进程的SP指针保存到进程的PCB当中
	(3)修改当前被中断进程的PCB信息
	(4)保存当前被中断进程的PCB到相关的队列
	(5)选择下一个待运行的进程，分配CPU资源
	(6)中断返回的时候原样恢复
```

