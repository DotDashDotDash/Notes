-------

### 目录



<!-- GFM-TOC -->

* [一、中央处理器](#一中央处理器)
* [二、存储系统](#二存储系统)
* [三、指令系统](#三指令系统)
* [四、I/O系统](#四i/o系统)
* [五、数据的表示与计算](#五数据的表示与计算)

<!-- GFM-TOC -->



# 一、中央处理器

1. **计算机异常的类型有哪些?**

```markdown
1. 中断(interrupt): 中断来自I/O设备的信号，中断是异步的，且总是返回到当前指令的下一条指令
2. 陷阱(trap): 用户发起的有意的异常，用于从用户态切换到内核态，陷阱是同步的，且总是返回到当前指令的下一条指令
3. 故障(fault): 潜在的可恢复的错误，故障是同步的，可能返回到当前指令，最典型的故障就是“缺页故障”
4. 终止(abort): 不可恢复的错误，终止是同步的，且不会返回

判断下列异常的类别:
1. 除法错误: 故障
2. 地址保护: 故障
3. 缺页: 故障
4. 机器检查: 终止
5. 操作系统定义的异常: 中断或陷阱
```

2. **CPU分为哪几个部分？分别实现了什么功能？**

```markdown
1. 运算器: 主要完成对数据的加工
	(1)算术逻辑单元ALU
	(2)通用寄存器组
	(3)暂存寄存器
	(4)程序状态字寄存器PSW
	(5)累加寄存器ACC
	(6)计数器CT
2. 控制器: 完成对计算机的指令控制，操作控制，时间控制，中断处理
	(1)存储器地址寄存器MAR
	(2)存储器数据寄存器MDR
	(3)指令寄存器IR
	(4)指令译码器ID
	(5)程序计数器PC
	(6)操作控制单元CU
```

3. **程序状态字寄存器PSW和汇编中的条件转移**

```markdown
PSW是一个16位的寄存器，反映了CPU运算的状态特征并存放了某些控制标志。

CF: 进位标志位，当执行一个加法或者减法运算，最高位产生进位或者借位的时候，CF=1，否则CF=0
ZF: 零标志位，若当前运算的结果等于0，则ZF=1，否则ZF=0
SF: 符号标志位，该标志位与运算结果的最高位相同，即如果运算结果为“负”，SF=1，若运算结果为“正”，则SF=0
OF: 溢出标志位，若运算的结果超过机器能够表示的范围，则OF=1。OF=最高位进位(异或)次高位进位
PF: 奇偶标志位，当运算结果的最低16位含有偶数个1则PF=1
AF: 辅助进位标志位，一个加法(减法)的低4位向高4位有进位(或者借位)时AF=1否则AF=0
IF: 中断标志位，表示CPU是否可以响应可屏蔽中断
DF: 表示串处理指令的处理方向，DF=1表示串处理过程中地址自动递减，否则自动递增

下面重点对OF总结一下，OF=1的情况说明了数据运算发生了溢出，假设最高位(符号位)的进位为C1，次高位(最高数值位)的进位为C2
则OF=C1^C2,例如：

Example 1: 01111111B(+127)与0 0000001B(+1)相加，得10000000B(-128)
		  可以观察到，上述式子C1=0，C2=1, OF=C1^C2=1，说明发生了溢出
Example 2: 01111111B(+127)与10000001B(-127)相加，得000000000B(+0)
		  可以观察到，上述式子C1=1, C2=1，OF=C1^C2=0，说明没有发生溢出
Example 3: FFFFFFFFH(-1)与00000010H(+16相加)，得0000000FH
		  可以观察到，上述式子C1=1,C2=1，OF=C1^C2=0，说明没有发生溢出
		  
注意！计算机中两个数的相减虽然是采用补码相加的形式进行的运算，但是补码相加只是一个过程，减法运算的时候，只需要判断被减数
与减数哪一个大，直接得到借位标志！！！二进制判断太麻烦了，这是一种简便方法
```

4. **几个周期**

```markdown
1. 指令周期：FE,ID,EX,INT
2. 取指周期：从内存中读出一个指令字的最短时间
3. 存取时间：发起一次MM读/写及完成读/写的时间
4. 存取周期：连续完成两次读/写之间的“最短”时间间隔，也就是存取时间的最小值
5. 机器周期：执行指令周期当中一步相对完整的操作所用的时间，因为CPU速度比MM快，因此把机器周期一般设置为存取周期
6. 时钟周期：计算机基本的时序单位，通常是完成一个微操作所用的时间
```

5. **硬布线微程序控制器微指令编写汇总**

```markdown
1. 取指周期(通用)
	C1: (PC)→MAR				//有效控制信号: PCout, MARin
	C2: M(MAR)→MDR, (PC)+1→PC	//有效控制信号: MemR, MDRin, PC+1
	C3: (MDR)→IR				//有效控制信号: MDRout, IRin
	C4: 指令译码(也可以放在C3)	  //无有效控制信号

2. 加法: (R0)+((R1))→(R1)
	c1: (R1)→MAR				//有效控制信号: R1out, MARin
	C2: M(MAR)→MDR				//有效控制信号: MemR, MDRin
	C3: (MDR)→A					//有效控制信号: MDRout, Ain
	C4: (R0)+(A)→AC				//有效控制信号: ROout, Aout, ACin
	C5: (AC)→MDR				//有效控制信号: ACout, MDRin
	C6: (MDR)→M(MAR)			//有效控制信号: MDRout, MemW

3. 取数: LDA X: (X)→ACC
	C1: X→MAR(X可以是立即数，可以是寄存器)	//有效控制信号: MARin
	C2: M(MAR)→MDR				//有效控制信号: MemR, MDRin
	C3: (MDR)→ALU→ACC			//有效控制信号: MDRout, ALUin, ALUout, ACCin

4. 存数: STA X: (ACC)→(X)
	C1: X→MAR(X可以是立即数，可以是寄存器)	//有效控制信号: MARin
	C2: (ACC)→MDR				//有效控制信号: ACCout, MDRin
	C3: (MDR)→M(MAR)			//有效控制信号: MDRout, MemW

5. 立即数加法: ADD #a: (ACC)+a→ACC
	C1: Ad(IR)→R1				//有效控制信号: IRout, R1in
	C2: (ACC)+(R1)→R2			//有效控制信号: ACCout, R1out, R2in
	C3: (R2)→ACC				//有效控制信号: R2out, ACCin
	
6. 间址周期
	C1: Ad(IR)→MAR				//有效控制信号： IRout, MARin
	C2: M(MAR)→MDR				//有效控制信号： MemR, MDRin

7. 跳转指令: JMP K
	C1: (SP)-1→SP, (SP)→MAR		//有效控制信号: SP-1, SPout, MARin
	C2: (PC)→MDR				//有效控制信号: PCout, MDRin
	C3: (MDR)→M(MAR)			//有效控制信号: MDRout, MemW
	C4: Ad(IR)→MDR				//有效控制信号: IRout, MDRin
	C5: (MDR)→PC				//有效控制信号: MDRout, PCin

8. 中断处理:
	C1: 0→INT, 0→MAR			//有效控制信号: MARin
	C2: (PC)→MDR				//有效控制信号： PCout, MARin
	C3: (MDR)→M(MAR)			//有效控制信号： MDRout, MemW
	C4: 中断向量→PC				 //有效控制信号:	PCin
```

6. **若采用微程序控制器方式，则微指令比硬布线控制器多哪些微指令？**

```markdown
1. OP(IR)→CMAR		//首条微指令的地址
2. CM(CMAR)→CMDR	//将对应CM中的位于CMAR中的指令传送到CMDR中
3. Ad(CMDR)→CMAR	//当前微指令的顺序控制字段作为下一条微指令的地址
```

7. **微程序控制器方式下，微地址是如何形成的**

```markdown
微程序控制器一共有3个部件影响微地址的形成，即顺序逻辑，CMAR，CMDR
1. 在取指阶段，OP(IR)经微地址形成部件形成初始微程序的地址，之后微地址的形成就不需要微地址形成部件了
2. 控制存储器CS通过CMAR取出对应地址的微指令，存放到CMDR当中
3. CMDR中的下地址字段被传送到顺序逻辑模块，注意，这里只是默认的下地址，还要经过顺序逻辑的判断，判断的条件来自于哪里？
   判断的条件来自于微指令的“判别测试”字段，通过“判断测试字段来判断程序是否需要进行转移，如果判断不通过或者不判断，下
   一条微指令的地址就是前面那个默认的CMDR中的下地址字段，否则还要加上相应的偏移量来形成最终的下地址字段
4. 重复过程2
```

8. **已知某计算机指令系统一共有n种操作，采用微程序控制器时，控制存储器CS中至少有多少微程序？**

```markdown
1. 所有计算机都有取指微程序，因此至少是n+1，一般情况下还有间址微程序
2. 若计算机带中断系统，那么有n+2个微程序
```

9. **微指令的编码**

```markdown
1. 直接编码：编码效率低，执行效率高
2. 字段直接编码：编码效率高，执行效率低
	(1) 互斥的微命令被编码在同一个字段，同时对于每一个互斥类，还要预留一个全0字段表示这个互斥类不操作
	(2) 在微指令的判断测试字段，同样还要有全0字段表示不进行判别测试
3. 字段间接编码: 某些字段受其他字段的控制，这种编码方式降低了微指令的并行性
```

10. **控制存储器的容量**

```markdown
Example 1: 已知计算机有80条指令，每条指令由4条微指令组成，其中有一条微指令为取指微指令，是所有指令公用的，求CM容量
Solution: 由题知计算机共有3x80+1=241条微指令，而CM中的微指令条数是2的幂次方，因此CM容量为256x32位

Example 2: 已知计算机采用水平编码方式，有28条微指令，6个可互斥的外部判定条件，CM容量为512x40位，求微指令格式
Solution: 由题知微指令的字长为40位，下地址字段为(40-28-3)=6位，因此微指令的格式为28/3/9
注意：互斥条件的判定为编码的方式！！！！！！

Example 3: 已知计算机有52个控制信号，构成5个互斥的微命令组，各组分别包含5,8,2,15,22个微命令，已知可以外部判定的条件有2个，
		   微指令字长28位，求微指令格式
Solution: 由题知微指令字长为28位，因此各互斥组的位数为3,4,2,4,5,判定字段的位数为2，下地址字段为28-3-4-2-4-5-2=8
```

11. **流水线的分类**

```markdown
1. 部件级，处理机级和处理机间级
2. 单功能流水线和多功能流水线
	(1)单功能是指只能实现一种固定的专门功能的流水线
	(2)多功能是指通过各段之间的不同连接方式可以同时或者不同时实现多种功能的流水线
3. 动态流水线和静态流水线
	(1)静态流水线：同一时间内，流水线的各段只能按照同一种功能的连接方式工作
	(2)动态流水线：同一时间内，当某段正在进行某种运算，另外一些段正在进行另外一种运算
4. 线性流水线和非线性流水线
	(1)线性流水线：从输入到输出，每一个段只能经过一次且没有反馈
	(2)非线性流水线：某些功能段能进行多次的通过，适合递归运算
5. 超标量流水线：每个时钟周期可以并发执行多条指令，为此需要配置多个功能部件，不能调整指令执行的顺序，但是可以
   通过编译优化技术将多个可以并行的指令搭配起来
6. 超流水线：一个时钟周期内再分段，也不能调整指令执行的顺序，需要编译优化技术
7. 超长指令字：将多个可以并行的指令组合成一个超长的指令字
```

12. **流水线的各种冲突与冒险**

```markdown
1. 数据冒险：下条指令需要访问上一条指令未被写回的结果，引起数据冒险
	(1)硬件阻塞null和软件阻塞NOP推迟后序指令的执行
	(2)常考：设置数据旁路，不需要等待数据被写回WB，在EX阶段就被写回到寄存器中
	(3)编译优化，调整指令执行的顺序
2. 控制冲突：一条指令要确定下一条指令的位置，比如转移调用等因错误改变PC而导致流水线断流，引起控制冒险
	(1)对转移指令进行分支预测，尽快生成目标转移地址。
		a. 静态预测：预测条件总是不满足，继续执行分支指令的后序指令
		b. 动态预测：更具程序执行的历史情况，进行动态预测，有较高的预测准确率
	(2)把预测成功和预测不成功两个方向的指令都取了
	(3)加快形成条件码
	(4)提高转移方向的准确率(屁话)
```

13. **坑点：指令流水线中的ID与IF并行问题**

```markdown
1. 若题目没有特殊要求且观察程序之间的相互顺序没有很明显的先后顺序，IF段可以一个周期执行一次
↑
|
|		  IF--ID--EX--MM--WB
|     IF--ID--EX--MM--WB
├-IF--ID--EX--MM--WB
└------------------------------------→

2. 对于有流水线数据冒险的情况1而言，IF段可以不与ID段并行
↑
|
|             IF--ID--EX--MM--WB
|     IF--ID--EX--MM--WB
├-IF--ID--EX--MM--WB
└------------------------------------→

3. 如果要求每条指令按序发射，按序接收，那么IF与ID段一定要并行
↑
|
|                 IF--ID--EX--MM--WB
|     IF----------ID--EX--MM--WB
├-IF--ID--EX--MM--WB
└------------------------------------→
```

14. **什么是指令流水线的数据通路?**

```markdown
五阶段流水线可以分为取指IF，译码ID，执行EX，存储器读MEM，写回WB。数字系统中，各个子系统通过数据总线连接而成的数据传送
路径称为数据通路，包括PC,ALU,GRS,取指部件。数据通路不包含控制部件
```

15. **吐血整理，5段流水线各段的功能以及每段对应的什么操作**

```markdown
五段流水线顾名思义，就是ID,IF,EX,M,WB

1. IF: 以程序计数器PC中的内容放到MAR中，然后从存储器中取出相应的指令，同时PC加指令字长，指向下一条指令
2. ID: 对指令进行译码，并用IR中的Ad字段去访问通用寄存器组，读出所需的操作数(或者其他形式，例如立即数，这取决于寻址方式的不同)
3. EX: 执行/有效地址计算周期，对于不同的指令，所进行的操作是不一样的
	(1)Load/Store: ALU把指令中所指的寄存器与形式地址相加，得到访存的有效地址
	(2)除了Load/Store，其余的在EX段都是进行操作数的运算
	* 总结上面，Load/Store在这一段计算的是有效地址，而其他ALU运算，进行的是操作数的运算
	(3)分支指令: ALU将指令中的偏移量与PC相加，得到转移目标的地址
4. M: 存储器访问阶段: !!!!!!除了Load/Store还有分支指令，其他指令在这一个周期不做任何操作！！！！！！！！！！！！！！！！
	(1)Load: 根据EX段得到的有效地址计算出将要取得数据的地址，从存储器中取出数据
	(2)分支指令: 将计算的分支指令地址送入PC，到此，分支指令执行完成！！！！！！！！！！！！！
	(3)Store: 根据EX段得到的有效地址，写回到存储器，到此，Store指令执行完成!!!!!!!!
5. WB: ALU运算和Load把结果写回到通用寄存器组！！！！注意了，是写回到通用寄存器组！！！！！

总结一下：分支/Store在5段流水线中只占用4个周期，Load/其他指令占用5个周期!!!!!

Example: 已知下面顺序执行5条指令，要求按序发射，按序完成，请画出流水线的执行过程:

I1: LOAD R1, [a]	//M(a)→R1
I2: LOAD R2, [b]	//M(b)→R2
I3: SHL R1			//(R1)x2→R1
I4: ADD R1,R2		//(R1)+(R2)→R2
I5: STORE R2, [a]	//(R2)→M(a)

要点：
1. 按序发射，按序完成，故下一段指令IF和上一段指令ID段并行
2. 注意数据相关及各流水段的作用

解释： I1和I2都是取不互相干的数，因此互不干扰，正常执行。I3需要用到R1，R1为Load，需要等到WB结束，同理
I3需要等到I2的WB结束，I4需要等到I3的WB结束，I5需要等到I4的WB结束
```

|      | C1   | C2   | C3   | C4   | C5   | C6   | C7   | C8   | C9   | C10  | C11  | C12  | C13  | C14  | C15  | C16  | C17  |
| ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |
| I1   | IF   | ID   | EX   | ME   | WB   |      |      |      |      |      |      |      |      |      |      |      |      |
| I2   |      | IF   | ID   | EX   | ME   | WB   |      |      |      |      |      |      |      |      |      |      |      |
| I3   |      |      | IF   |      |      | ID   | EX   | ME   | WB   |      |      |      |      |      |      |      |      |
| I4   |      |      |      |      |      | IF   |      |      |      | ID   | EX   | ME   | WB   |      |      |      |      |
| I5   |      |      |      |      |      |      |      |      |      | IF   |      |      |      | ID   | EX   | ME   | WB   |



# 五、数据的表示与计算

1. **在进行n位的整数乘法时，假设乘法的结果为2n位，判断在imul和mul情况下乘法结果是否发生溢出？**

```markdown
1. 在mul情况下，如果高n位均为0，则乘法结果没有发生溢出
2. 在imul情况下，如果高n位是低n位的符号扩展，则没有发生溢出，即高n+1位全0或者全1的时候，乘法结果没有发生溢出
```

2. **定点数要进行×2运算，可以通过移位shl进行，那么浮点数呢？可以通过shl进行×2吗？**

```markdown
不行，因为浮点数的组成为(符号位，阶码位，尾数位)，单纯的shl也会造成阶码x2，其实这样是不对的
因为浮点数尾数x2的时候，阶码需要+1而不是x2，因此浮点运算不能使用shl
```

3. **在使用相对寻址计算跳转指令地址的时候，PC的值是unsigned而offset是补码，如何计算得到跳转后的指令地址？**

```markdown
假设PC中的内容是0x00487256,指令中的offset为0xffff(补码-1)
首先将offset符号扩展为32位，即0xffffffff
其次计算：0x00487256 + 0xffffffff = 0x00487255(补)
即得到正确的跳转地址
```

4. **int, float, double, char之间的转换问题. i, f, d分别为int, float, double类型**

```markdown
1. i == (int) (float) i
解析：int精度比float高，因为int的31位都可以表示数字，但是float只有24位的精度，所以当int转float会造成精度丢失

2. f == (float) (int) f
解析：float有小数部分，当转化为int的时候，小数位可能会丢失，因此可能会丢失精度

3. i == (int) (double) i
解析：double有比int更大的精度表示范围，因此int转double不会丢失精度

4. f = (float) (double) f
解析：double有比float更大的精度表示范围，因此float转double不会造成精度丢失

5. d == (float) d
解析：double转float可能会丢失精度

6. f == -(-f)
解析：浮点数取反就是简单的符号位取反

7. f == (d + f) - d
解析：这个要特别注意，因为float和double类型的运算极有可能需要对阶，因此对阶过程中可能会出现下溢
```

5. **IEEE754浮点数的总结**

| 值的类型       | 符号 | 阶码    | 尾数 | 值             |
| -------------- | ---- | ------- | ---- | -------------- |
| 正零           | 0    | 全0     | 全0  | 0              |
| 负零           | 1    | 全0     | 全0  | -0             |
| 正无穷大       | 0    | 全1     | 全0  | +∞             |
| 负无穷大       | 1    | 全1     | 全0  | -∞             |
| 无定义数       | 0或1 | 全1     | ≠0   | NaN            |
| 规格化非零正数 | 0    | (0,255) | f    | 1.f×2^(e-127)  |
| 规格化非零负数 | 1    | (0,255) | f    | -1.f×2^(e-127) |
| 非规格化正数   | 0    | 0       | f≠0  | 0.f×2^(-126)   |
| 非规格化负数   | 1    | 0       | f≠0  | -0.f×2^(-126)  |