-------

### 目录



<!-- GFM-TOC -->

* [一、中央处理器](#一中央处理器)
* [二、存储系统](#二存储系统)
* [三、指令系统](#三指令系统)
* [四、I/O系统](#四i/o系统)

<!-- GFM-TOC -->



# 一、中央处理器

1. **计算机异常的类型有哪些?**

```markdown
1. 中断(interrupt): 中断来自I/O设备的信号，中断是异步的，且总是返回到当前指令的下一条指令
2. 陷阱(trap): 用户发起的有意的异常，用于从用户态切换到内核态，陷阱是同步的，且总是返回到当前指令的下一条指令
3. 故障(fault): 潜在的可恢复的错误，故障是同步的，可能返回到当前指令，最典型的故障就是“缺页故障”
4. 终止(abort): 不可恢复的错误，终止是同步的，且不会返回

判断下列异常的类别:
1. 除法错误: 故障
2. 地址保护: 故障
3. 缺页: 故障
4. 机器检查: 终止
5. 操作系统定义的异常: 中断或陷阱
```

2. **CPU分为哪几个部分？分别实现了什么功能？**

```markdown
1. 运算器: 主要完成对数据的加工
	(1)算术逻辑单元ALU
	(2)通用寄存器组
	(3)暂存寄存器
	(4)程序状态字寄存器PSW
	(5)累加寄存器ACC
	(6)计数器CT
2. 控制器: 完成对计算机的指令控制，操作控制，时间控制，中断处理
	(1)存储器地址寄存器MAR
	(2)存储器数据寄存器MDR
	(3)指令寄存器IR
	(4)指令译码器ID
	(5)程序计数器PC
	(6)操作控制单元CU
```

3. **程序状态字寄存器PSW和汇编中的条件转移**

```markdown
PSW是一个16位的寄存器，反映了CPU运算的状态特征并存放了某些控制标志。

CF: 进位标志位，当执行一个加法或者减法运算，最高位产生进位或者借位的时候，CF=1，否则CF=0
ZF: 零标志位，若当前运算的结果等于0，则ZF=1，否则ZF=0
SF: 符号标志位，该标志位与运算结果的最高位相同，即如果运算结果为“负”，SF=1，若运算结果为“正”，则SF=0
OF: 溢出标志位，若运算的结果超过机器能够表示的范围，则OF=1。OF=最高位进位(异或)次高位进位
PF: 奇偶标志位，当运算结果的最低16位含有偶数个1则PF=1
AF: 辅助进位标志位，一个加法(减法)的低4位向高4位有进位(或者借位)时AF=1否则AF=0
IF: 中断标志位，表示CPU是否可以响应可屏蔽中断
DF: 表示串处理指令的处理方向，DF=1表示串处理过程中地址自动递减，否则自动递增

下面重点对OF总结一下，OF=1的情况说明了数据运算发生了溢出，假设最高位(符号位)的进位为C1，次高位(最高数值位)的进位为C2
则OF=C1^C2,例如：

Example 1: 01111111B(+127)与0 0000001B(+1)相加，得10000000B(-128)
		  可以观察到，上述式子C1=0，C2=1, OF=C1^C2=1，说明发生了溢出
Example 2: 01111111B(+127)与10000001B(-127)相加，得000000000B(+0)
		  可以观察到，上述式子C1=1, C2=1，OF=C1^C2=0，说明没有发生溢出
Example 3: FFFFFFFFH(-1)与00000010H(+16相加)，得0000000FH
		  可以观察到，上述式子C1=1,C2=1，OF=C1^C2=0，说明没有发生溢出
		  
注意！计算机中两个数的相减虽然是采用补码相加的形式进行的运算，但是补码相加只是一个过程，减法运算的时候，只需要判断被减数
与减数哪一个大，直接得到借位标志！！！二进制判断太麻烦了，这是一种简便方法
```

4. **几个周期**

```markdown
1. 指令周期：FE,ID,EX,INT
2. 取指周期：从内存中读出一个指令字的最短时间
3. 存取时间：发起一次MM读/写及完成读/写的时间
4. 存取周期：连续完成两次读/写之间的“最短”时间间隔，也就是存取时间的最小值
5. 机器周期：执行指令周期当中一步相对完整的操作所用的时间，因为CPU速度比MM快，因此把机器周期一般设置为存取周期
6. 时钟周期：计算机基本的时序单位，通常是完成一个微操作所用的时间
```

5. **硬布线微程序控制器微指令编写汇总**

```markdown
1. 取指周期(通用)
	C1: (PC)→MAR				//有效控制信号: PCout, MARin
	C2: M(MAR)→MDR, (PC)+1→PC	//有效控制信号: MemR, MDRin, PC+1
	C3: (MDR)→IR				//有效控制信号: MDRout, IRin
	C4: 指令译码(也可以放在C3)	  //无有效控制信号

2. 加法: (R0)+((R1))→(R1)
	c1: (R1)→MAR				//有效控制信号: R1out, MARin
	C2: M(MAR)→MDR				//有效控制信号: MemR, MDRin
	C3: (MDR)→A					//有效控制信号: MDRout, Ain
	C4: (R0)+(A)→AC				//有效控制信号: ROout, Aout, ACin
	C5: (AC)→MDR				//有效控制信号: ACout, MDRin
	C6: (MDR)→M(MAR)			//有效控制信号: MDRout, MemW

3. 
```

