-------

### 目录



<!-- GFM-TOC -->

* [一、中央处理器](#一中央处理器)
* [二、存储系统](#二存储系统)
* [三、指令系统](#三指令系统)
* [四、I/O系统](#四i/o系统)

<!-- GFM-TOC -->



# 一、中央处理器

1. **计算机异常的类型有哪些?**

```markdown
1. 中断(interrupt): 中断来自I/O设备的信号，中断是异步的，且总是返回到当前指令的下一条指令
2. 陷阱(trap): 用户发起的有意的异常，用于从用户态切换到内核态，陷阱是同步的，且总是返回到当前指令的下一条指令
3. 故障(fault): 潜在的可恢复的错误，故障是同步的，可能返回到当前指令，最典型的故障就是“缺页故障”
4. 终止(abort): 不可恢复的错误，终止是同步的，且不会返回

判断下列异常的类别:
1. 除法错误: 故障
2. 地址保护: 故障
3. 缺页: 故障
4. 机器检查: 终止
5. 操作系统定义的异常: 中断或陷阱
```

2. **CPU分为哪几个部分？分别实现了什么功能？**

```markdown
1. 运算器: 主要完成对数据的加工
	(1)算术逻辑单元ALU
	(2)通用寄存器组
	(3)暂存寄存器
	(4)程序状态字寄存器PSW
	(5)累加寄存器ACC
	(6)计数器CT
2. 控制器: 完成对计算机的指令控制，操作控制，时间控制，中断处理
	(1)存储器地址寄存器MAR
	(2)存储器数据寄存器MDR
	(3)指令寄存器IR
	(4)指令译码器ID
	(5)程序计数器PC
	(6)操作控制单元CU
```

3. **程序状态字寄存器PSW和汇编中的条件转移**

```markdown
PSW是一个16位的寄存器，反映了CPU运算的状态特征并存放了某些控制标志。

CF: 进位标志位，当执行一个加法或者减法运算，最高位产生进位或者借位的时候，CF=1，否则CF=0
ZF: 零标志位，若当前运算的结果等于0，则ZF=1，否则ZF=0
SF: 符号标志位，该标志位与运算结果的最高位相同，即如果运算结果为“负”，SF=1，若运算结果为“正”，则SF=0
OF: 溢出标志位，若运算的结果超过机器能够表示的范围，则OF=1。OF=最高位进位(异或)次高位进位
PF: 奇偶标志位，当运算结果的最低16位含有偶数个1则PF=1
AF: 辅助进位标志位，一个加法(减法)的低4位向高4位有进位(或者借位)时AF=1否则AF=0
IF: 中断标志位，表示CPU是否可以响应可屏蔽中断
DF: 表示串处理指令的处理方向，DF=1表示串处理过程中地址自动递减，否则自动递增

下面重点对OF总结一下，OF=1的情况说明了数据运算发生了溢出，假设最高位(符号位)的进位为C1，次高位(最高数值位)的进位为C2
则OF=C1^C2,例如：

Example 1: 01111111B(+127)与0 0000001B(+1)相加，得10000000B(-128)
		  可以观察到，上述式子C1=0，C2=1, OF=C1^C2=1，说明发生了溢出
Example 2: 01111111B(+127)与10000001B(-127)相加，得000000000B(+0)
		  可以观察到，上述式子C1=1, C2=1，OF=C1^C2=0，说明没有发生溢出
Example 3: FFFFFFFFH(-1)与00000010H(+16相加)，得0000000FH
		  可以观察到，上述式子C1=1,C2=1，OF=C1^C2=0，说明没有发生溢出
		  
注意！计算机中两个数的相减虽然是采用补码相加的形式进行的运算，但是补码相加只是一个过程，减法运算的时候，只需要判断被减数
与减数哪一个大，直接得到借位标志！！！二进制判断太麻烦了，这是一种简便方法
```

4. **几个周期**

```markdown
1. 指令周期：FE,ID,EX,INT
2. 取指周期：从内存中读出一个指令字的最短时间
3. 存取时间：发起一次MM读/写及完成读/写的时间
4. 存取周期：连续完成两次读/写之间的“最短”时间间隔，也就是存取时间的最小值
5. 机器周期：执行指令周期当中一步相对完整的操作所用的时间，因为CPU速度比MM快，因此把机器周期一般设置为存取周期
6. 时钟周期：计算机基本的时序单位，通常是完成一个微操作所用的时间
```

5. **硬布线微程序控制器微指令编写汇总**

```markdown
1. 取指周期(通用)
	C1: (PC)→MAR				//有效控制信号: PCout, MARin
	C2: M(MAR)→MDR, (PC)+1→PC	//有效控制信号: MemR, MDRin, PC+1
	C3: (MDR)→IR				//有效控制信号: MDRout, IRin
	C4: 指令译码(也可以放在C3)	  //无有效控制信号

2. 加法: (R0)+((R1))→(R1)
	c1: (R1)→MAR				//有效控制信号: R1out, MARin
	C2: M(MAR)→MDR				//有效控制信号: MemR, MDRin
	C3: (MDR)→A					//有效控制信号: MDRout, Ain
	C4: (R0)+(A)→AC				//有效控制信号: ROout, Aout, ACin
	C5: (AC)→MDR				//有效控制信号: ACout, MDRin
	C6: (MDR)→M(MAR)			//有效控制信号: MDRout, MemW

3. 取数: LDA X: (X)→ACC
	C1: X→MAR(X可以是立即数，可以是寄存器)	//有效控制信号: MARin
	C2: M(MAR)→MDR				//有效控制信号: MemR, MDRin
	C3: (MDR)→ALU→ACC			//有效控制信号: MDRout, ALUin, ALUout, ACCin

4. 存数: STA X: (ACC)→(X)
	C1: X→MAR(X可以是立即数，可以是寄存器)	//有效控制信号: MARin
	C2: (ACC)→MDR				//有效控制信号: ACCout, MDRin
	C3: (MDR)→M(MAR)			//有效控制信号: MDRout, MemW

5. 立即数加法: ADD #a: (ACC)+a→ACC
	C1: Ad(IR)→R1				//有效控制信号: IRout, R1in
	C2: (ACC)+(R1)→R2			//有效控制信号: ACCout, R1out, R2in
	C3: (R2)→ACC				//有效控制信号: R2out, ACCin
	
6. 间址周期
	C1: Ad(IR)→MAR				//有效控制信号： IRout, MARin
	C2: M(MAR)→MDR				//有效控制信号： MemR, MDRin

7. 跳转指令: JMP K
	C1: (SP)-1→SP, (SP)→MAR		//有效控制信号: SP-1, SPout, MARin
	C2: (PC)→MDR				//有效控制信号: PCout, MDRin
	C3: (MDR)→M(MAR)			//有效控制信号: MDRout, MemW
	C4: Ad(IR)→MDR				//有效控制信号: IRout, MDRin
	C5: (MDR)→PC				//有效控制信号: MDRout, PCin

8. 中断处理:
	C1: 0→INT, 0→MAR			//有效控制信号: MARin
	C2: (PC)→MDR				//有效控制信号： PCout, MARin
	C3: (MDR)→M(MAR)			//有效控制信号： MDRout, MemW
	C4: 中断向量→PC				 //有效控制信号:	PCin
```

6. **若采用微程序控制器方式，则微指令比硬布线控制器多哪些微指令？**

```markdown
1. OP(IR)→CMAR		//首条微指令的地址
2. CM(CMAR)→CMDR	//将对应CM中的位于CMAR中的指令传送到CMDR中
3. Ad(CMDR)→CMAR	//当前微指令的顺序控制字段作为下一条微指令的地址
```

7. **微程序控制器方式下，微地址是如何形成的**

```markdown
微程序控制器一共有3个部件影响微地址的形成，即顺序逻辑，CMAR，CMDR
1. 在取指阶段，OP(IR)经微地址形成部件形成初始微程序的地址，之后微地址的形成就不需要微地址形成部件了
2. 控制存储器CS通过CMAR取出对应地址的微指令，存放到CMDR当中
3. CMDR中的下地址字段被传送到顺序逻辑模块，注意，这里只是默认的下地址，还要经过顺序逻辑的判断，判断的条件来自于哪里？
   判断的条件来自于微指令的“判别测试”字段，通过“判断测试字段来判断程序是否需要进行转移，如果判断不通过或者不判断，下
   一条微指令的地址就是前面那个默认的CMDR中的下地址字段，否则还要加上相应的偏移量来形成最终的下地址字段
4. 重复过程2
```

8. **已知某计算机指令系统一共有n种操作，采用微程序控制器时，控制存储器CS中至少有多少微程序？**

```markdown
1. 所有计算机都有取指微程序，因此至少是n+1，一般情况下还有间址微程序
2. 若计算机带中断系统，那么有n+2个微程序
```

9. **微指令的编码**

```markdown
1. 直接编码：编码效率低，执行效率高
2. 字段直接编码：编码效率高，执行效率低
	(1) 互斥的微命令被编码在同一个字段，同时对于每一个互斥类，还要预留一个全0字段表示这个互斥类不操作
	(2) 在微指令的判断测试字段，同样还要有全0字段表示不进行判别测试
3. 字段间接编码: 某些字段受其他字段的控制，这种编码方式降低了微指令的并行性
```

10. **控制存储器的容量**

```markdown
Example 1: 已知计算机有80条指令，每条指令由4条微指令组成，其中有一条微指令为取指微指令，是所有指令公用的，求CM容量
Solution: 由题知计算机共有3x80+1=241条微指令，而CM中的微指令条数是2的幂次方，因此CM容量为256x32位

Example 2: 已知计算机采用水平编码方式，有28条微指令，6个可互斥的外部判定条件，CM容量为512x40位，求微指令格式
Solution: 由题知微指令的字长为40位，下地址字段为(40-28-3)=6位，因此微指令的格式为28/3/9
注意：互斥条件的判定为编码的方式！！！！！！

Example 3: 已知计算机有52个控制信号，构成5个互斥的微命令组，各组分别包含5,8,2,15,22个微命令，已知可以外部判定的条件有2个，
		   微指令字长28位，求微指令格式
Solution: 由题知微指令字长为28位，因此各互斥组的位数为3,4,2,4,5,判定字段的位数为2，下地址字段为28-3-4-2-4-5-2=8
```

11. **流水线的分类**

```markdown
1. 部件级，处理机级和处理机间级
2. 单功能流水线和多功能流水线
	(1)单功能是指只能实现一种固定的专门功能的流水线
	(2)多功能是指通过各段之间的不同连接方式可以同时或者不同时实现多种功能的流水线
3. 动态流水线和静态流水线
	(1)静态流水线：同一时间内，流水线的各段只能按照同一种功能的连接方式工作
	(2)动态流水线：同一时间内，当某段正在进行某种运算，另外一些段正在进行另外一种运算
4. 线性流水线和非线性流水线
	(1)线性流水线：从输入到输出，每一个段只能经过一次且没有反馈
	(2)非线性流水线：某些功能段能进行多次的通过，适合递归运算
5. 超标量流水线：每个时钟周期可以并发执行多条指令，为此需要配置多个功能部件，不能调整指令执行的顺序，但是可以
   通过编译优化技术将多个可以并行的指令搭配起来
6. 超流水线：一个时钟周期内再分段，也不能调整指令执行的顺序，需要编译优化技术
7. 超长指令字：将多个可以并行的指令组合成一个超长的指令字
```

12. **流水线的各种冲突与冒险**

```markdown
1. 数据冒险：下条指令需要访问上一条指令未被写回的结果，引起数据冒险
	(1)硬件阻塞null和软件阻塞NOP推迟后序指令的执行
	(2)常考：设置数据旁路，不需要等待数据被写回WB，在EX阶段就被写回到寄存器中
	(3)编译优化，调整指令执行的顺序
2. 控制冲突：一条指令要确定下一条指令的位置，比如转移调用等因错误改变PC而导致流水线断流，引起控制冒险
	(1)对转移指令进行分支预测，尽快生成目标转移地址。
		a. 静态预测：预测条件总是不满足，继续执行分支指令的后序指令
		b. 动态预测：更具程序执行的历史情况，进行动态预测，有较高的预测准确率
	(2)把预测成功和预测不成功两个方向的指令都取了
	(3)加快形成条件码
	(4)提高转移方向的准确率(屁话)
```

13. **坑点：指令流水线中的ID与IF并行问题**

```markdown
1. 若题目没有特殊要求且观察程序之间的相互顺序没有很明显的先后顺序，IF段可以一个周期执行一次
↑
|
|		  IF--ID--EX--MM--WB
|     IF--ID--EX--MM--WB
├-IF--ID--EX--MM--WB
└------------------------------------→

2. 对于有流水线数据冒险的情况1而言，IF段可以不与ID段并行
↑
|
|             IF--ID--EX--MM--WB
|     IF--ID--EX--MM--WB
├-IF--ID--EX--MM--WB
└------------------------------------→

3. 如果要求每条指令按序发射，按序接收，那么IF与ID段一定要并行
↑
|
|		            IF--ID--EX--MM--WB
|     IF------------ID--EX--MM--WB
├-IF--ID--EX--MM--WB
└------------------------------------→
```



