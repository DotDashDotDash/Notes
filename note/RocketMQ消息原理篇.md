## RocketMQ消息原理篇

### 前言

分布式消息系统始终不能回避的两个问题:

* **消息顺序性问题**
* **消息重复消费问题**

### 顺序消息问题

消息有序指的是可以按照消息的发送顺序来消费。例如：一笔订单产生了 3 条消息，分别是订单创建、订单付款、订单完成。消费时，要按照顺序依次消费才有意义。与此同时多笔订单之间又是可以并行消费的。首先来看如下示例：

假如生产者产生了2条消息：M1、M2，要保证这两条消息的顺序，应该怎样做？你脑中想到的可能是这样：

<div align=center><img src="/assets/ro2.png"/></div>

**你可能会采用这种方式保证消息顺序:**

假定M1发送到S1，M2发送到S2，如果要保证M1先于M2被消费，那么需要M1到达消费端被消费后，通知S2，然后S2再将M2发送到消费端。

**这个模型存在的问题是**，如果M1和M2分别发送到两台Server上，就不能保证M1先达到MQ集群，也不能保证M1被先消费。换个角度看，如果M2先于M1达到MQ集群，甚至M2被消费后，M1才达到消费端，这时消息也就乱序了，说明以上模型是不能保证消息的顺序的。如何才能在MQ集群保证消息的顺序？一种简单的方式就是将M1、M2发送到同一个Server上：

<div align=center><img src="/assets/ro3.png"/></div>

**这样可以保证M1先于M2到达MQServer（生产者等待M1发送成功后再发送M2）**，根据先达到先被消费的原则，M1会先于M2被消费，这样就保证了消息的顺序。

这个模型也仅仅是理论上可以保证消息的顺序，在实际场景中可能会遇到下面的问题：

<div align=center><img src="/assets/ro4.png"/></div>

**网络延迟问题**: 只要将消息从一台服务器发往另一台服务器，就会存在网络延迟问题。如上图所示，如果发送M1耗时大于发送M2的耗时，那么M2就仍将被先消费，仍然不能保证消息的顺序。即使M1和M2同时到达消费端，由于不清楚消费端1和消费端2的负载情况，仍然有可能出现M2先于M1被消费的情况。

那如何解决这个问题？将M1和M2发往同一个消费者，且发送M1后，需要消费端响应成功后才能发送M2。

聪明的你可能已经想到另外的问题：如果M1被发送到消费端后，消费端1没有响应，那是继续发送M2呢，还是重新发送M1？一般为了保证消息一定被消费，肯定会选择重发M1到另外一个消费端2，就如下图所示。

<div align=center><img src="/assets/ro5.png"/></div>

但是这又又又又会引发一个问题，**当ack出现网络延迟而导致消息的二次消费怎么办?**

那么RocketMQ是如何解决消息的顺序消费问题的呢？例如，RocketMQ会通过队列选择器将同一个订单号的信息发送到同一个队列当中。

### 消息重复消费

当消费端出现了两个相同的消息，该如何处置? 解决消息重复消费主要有两种手段，这两种手段往往搭配起来使用:

* 对接口执行幂等操作，保证关键业务只执行一次(例如支付接口)
* 保证每条消息都有自己的唯一ID，消息处理成功之后，在去重表中如果发现了同样ID的消息，不做处理