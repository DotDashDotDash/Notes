# MySQL存储

## MySQL存储引擎

MyISAM是MySQL在5.5版本之前的默认存储引擎，MySQL5.5之后的默认存储引擎是InnoDB

MyISAM和InnoDB的区别如下:

* **是否支持行级锁**: MyISAM只有表级锁，而InnoDB支持行级锁，默认为行级锁
* **是否支持事务**: MyISAM不支持事务，InnoDB支持事务
* **是否支持外键**: MyISAM不支持外键，InnoDB支持外键
* **是否支持崩溃后的安全恢复**: MyISAM强调性能，但是崩溃后无法恢复，而InnoDB支持事务的回滚以及故障的恢复
* **是否支持MVCC**: 仅InnoDB支持，MyISAM只支持单纯的加锁，而InnoDB支持不同的事务隔离策略

## 索引

MySQL使用的索引包括**哈希索引**和**Btree索引**，当查询的记录大多为单条记录的时候，使用哈希索引比较好，其他大部分的时候使用BTree索引比较好

* **MyISAM**: B+Tree叶节点的data域存放的是数据记录的地址。在索引检索的时候，首先按照B+Tree搜索算法搜索索引，如果指定的Key存在，则取出其 data 域的值，然后以 data 域的值为地址读取相应的数据记录。这被称为“非聚簇索引”。
* **InnoDB**: 其数据文件本身就是索引文件。相比MyISAM，索引文件和数据文件是分离的，其表数据文件本身就是按B+Tree组织的一个索引结构，树的叶节点data域保存了完整的数据记录。这个索引的key是数据表的主键，因此InnoDB表数据文件本身就是主索引。这被称为“聚簇索引（或聚集索引）”。而其余的索引都作为辅助索引，辅助索引的data域存储相应记录主键的值而不是地址，这也是和MyISAM不同的地方。在根据主索引搜索时，直接找到key所在的节点即可取出数据；在根据辅助索引查找时，则需要先取出主键的值，再走一遍主索引。 **因此，在设计表的时候，不建议使用过长的字段作为主键，也不建议使用非单调的字段作为主键，这样会造成主索引频繁分裂**

## MySQL查询缓存

开启查询缓存后在同样的查询条件以及数据情况下，会直接在缓存中返回结果。这里的查询条件包括查询本身、当前要查询的数据库、客户端协议版本号等一些可能影响结果的信息。因此任何两个查询在任何字符上的不同都会导致缓存不命中。此外，如果查询中包含任何用户自定义函数、存储函数、用户变量、临时表、MySQL库中的系统表，其查询结果也不会被缓存。

缓存建立之后，MySQL的查询缓存系统会跟踪查询中涉及的每张表，如果这些表（数据或结构）发生变化，那么和这张表相关的所有缓存数据都将失效。

缓存虽然能够提升数据库的查询性能，但是缓存同时也带来了额外的开销，每次查询后都要做一次缓存操作，失效后还要销毁。 因此，开启缓存查询要谨慎，尤其对于写密集的应用来说更是如此。如果开启，要注意合理控制缓存空间大小，一般来说其大小设置为几十MB比较合适。

## 参考链接

* [MySQL知识点梳理](https://github.com/Snailclimb/JavaGuide/blob/master/docs/database/MySQL.md)
* [MySQL索引菜鸟教程](https://www.runoob.com/mysql/mysql-index.html)
