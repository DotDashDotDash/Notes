# MySQL索引(面试重点)

### 1一. 前言

学了这么久的MySQL，最让我头疼的是啥，就是索引，看了不知道多少篇博文，博客，对于索引的认识还是停留在初级阶段，只知道索引就是一个帮助提高查询效率的一个玩意儿，但是其他的基本认识不深刻，最近打算好好整理一下有关MySQL索引的知识

### 二. 首先要先明白，索引能干什么

索引是帮助MySQL提高查询效率的一个高级数据结构

**为什么索引能帮助提高查询效率**

因为定义了索引的列是**排好序**的，但是这种排序会影响到where后面的查找，和order by后面的排序

### 三. 索引的分类

* **从存储结构上来分**: BTree索引，Hash索引，Full-Index索引，R-Tree索引
* **从应用的层次来说**: 普通索引，唯一索引，复合索引
* **从物理存储的层次来说**: 聚集索引，非聚集索引

下面简单谈谈几个索引的类型:

* **普通索引**: 一个索引只包含一列，一个表可以有多个普通索引
* **唯一索引**: 索引的列的值必须唯一，但是允许为null
* **复合索引**: 一个索引包含多个列
* **聚簇索引**: 并不是一个单独的索引类型，而是一种数据存储方式，InnoDB的聚簇索引其实就是在同一个结构中保持了BTree索引和数据行
* **非聚簇索引**: 除了聚簇索引，就是非聚簇索引

### 四. 索引的底层实现

#### 4.1 Hash索引

Hash索引的实现是基于Hash表的，**只有精确匹配索引所有列的查询才有效**

对于每一行的数据，存储引擎都会对所有的**索引列**计算一个Hash码，并且Hash索引将所有的哈希码存储在索引当中，同时在索引表中保存指向每个数据行的指针

<div align=center><img src="/assets/sql1.jpg"/></div>

#### 4.2 B-Tree索引(MySQL采用B+Tree)

B-Tree可以加速数据的访问，因为存储引擎不再需要进行全表扫描来获取数据，数据分布在各个节点当中(B+Tree是存放在叶子节点当中)

<div align=center><img src="/assets/sql2.jpg"/></div>

#### 4.3 B+Tree索引

B+Tree和B-Tree的区别就是B+Tree除了支持随机访问之外，还支持顺序访问

**相比B-Tree来说，进行范围查找时只需要查找两个节点，进行遍历即可，而B-Tree需要获取所有节点，相比之下B+Tree效率更高**

<div align=center><img src="/assets/sql3.jpg"/></div>

#### 4.4 从一个实例探究SQL索引的具体实现

假设有一张表

|id|	name|	birthday|
|:---:|:---:|:---:|
|1|	Tom|	1996-01-01|
|2|	Jann|	1996-01-04|
|3|	Ray|	1996-01-08|
|4|	Micheal|	1996-01-10|
|5|	Jack|	1996-01-13|
|6|	Steven|	1996-01-23|
|7|	Lily|	1996-01-25|

**MyISAM引擎中的实现**

<div align=center><img src="/assets/sql4.jpg"/></div>

**InnoDB中的实现**

<div align=center><img src="/assets/sql5.jpg"/></div>

<div align=center><img src="/assets/sql6.jpg"/></div>

### 五. 为什么索引结构默认使用B+Tree而不是Hash或者红黑树?

* Hash虽然可以快速定位，但是没有顺序，IO复杂度高
* 红黑树树高随数据量增加而增加，IO代价高

### 六. 为什么官方建议使用自增长主键作为索引

B+Tree树特性决定的，如果自增主键时连续的，在插入的过程中可以尽量减少分页，即使要进行分页，也只会分裂很少的一部分

自增长主键能保证每次插入数据都是插入到最后，能减少分裂和移动的频率

**插入连续的数据**

<div align=center><img src="/assets/sql7.gif"/></div>

**插入非连续的数据**

<div align=center><img src="/assets/sql8.gif"/></div>
