# Java线程

## 线程的生命周期

<div align=center><img src="/assets/thread.png"/></div>


## 终止线程的4种方式:

* 程序正常结束
* 标志控制线程结束，通常标志由volatile关键字标记
* interrupt()结束:
  * 情况1: 线程处于阻塞状态: 直接调用interrupt()会抛出一个异常，捕获这个异常同时跳出循环，线程才能结束，**只有调用interrupt()捕获异常，break跳出循环，线程才能正常退出run()**
  * 情况2: 线程处于非阻塞状态: 调用interrupt()后，isInterrupted()会返回true，和上面一样跳出循环
* stop()强制终止线程，这种终止线程的方法不是线程安全的，因为当调用stop()方法的时候，所有子模块的锁都会被释放，可能给系统带来无法承受的问题

## _wait()_

* 需要synchronized同步块，调用该方法的线程进入阻塞状态，直到有线程唤醒
* 释放锁，所以要在同步块中，不然没有锁何谈释放一说
* 一般是Object调用wait()，阻塞当前线程
* 参考代码[MyThreadCircle.waitAndNotify()](/src/concurrent/MyThreadCircle.java)

## _notify()_

* 与wait()搭配起来用
* 随机唤醒一个线程，这个随机性由jdk版本决定
* 也需要在同步块中

## _yield()_

* 不释放锁
* 让出当前的CPU时间片，使线程回到Runnable就绪状态，可与其他**同优先级** 的线程竞争时间片
* 参考代码[MyThreadCircle.doYield()](/src/concurrent/MyThreadCircle.java)
* native方法

## _join()_

* 不释放锁
* 在一个线程中调用t.join()就是等t线程先执行完再继续执行本线程
* 可将并行程序实现为串行程序
* 参考代码[MyThreadCircle.doJoin()](/src/concurrent/MyThreadCircle.java)

## _sleep()_

* 不释放锁
* 无法被唤醒，一般sleep时间到才醒来

## 参考链接

* [Java中yield()和join()的用法](https://blog.csdn.net/hust_yfang/article/details/79603032)
* [Java yield()详解](https://blog.csdn.net/dabing69221/article/details/17426953)
