# Java锁

## 乐观锁/悲观锁

* 乐观锁认为读多写少，即发生同时写的可能比较小
* 悲观锁认为写多读少，即发生同时写的可能比较大，每次写都要加锁，synchronized就是一个悲观锁

## 自旋锁

若持有锁的线程能够很快释放锁，那么等待锁的线程只需要稍稍等待一下(自旋)，不需要将线程从Runnable到Blocked进行转换，也就是阻塞当前线程，这部分开销是很大的

当然自旋锁也有缺点，**自旋是消耗CPU的**，如果长时间的自旋，消耗的资源会比线程的状态切换更加大

自旋锁有一个最长等待时间，这个自旋时间有如下变化:

* jdk1.6之前: 时间固定
* jdk1.6之后: 自适应自旋锁，根据上次自旋时间适应，还根据CPU线程数，<=CPUs/2自旋，>=CPUs/2阻塞
* 自旋锁的最坏情况是CPU A到CPU B的存储时间

## synchronized锁

参考[synchronized锁](/note/concurrent/synchronized.md)

## Semaphore信号量

类似ReentrantLock，几乎ReentrantLock的所有功能它都能实现

Semaphore设置的为可响应锁，也就是说，Semaphore.acquire()之后可以被Thread.interrupt()中断，类似ReentrantLock.lockInterruptibly()

## 重量级锁

synchronized就是一个重量级锁，它是一个悲观的加锁策略，避免了读/读冲突，重量级锁的实现依赖于底层操作系统的Mutex Lock

## 轻量级锁

锁的状态有四种

* 无锁状态
* 偏向锁
* 轻量级锁
* 重量级锁
**轻量级锁是为了解决在没有多线程交互的情况下加锁策略而导致的性能损耗，轻量级锁适用于线程交替执行##同步块，如果多个线程同时访问同一个轻量级锁，锁就会膨胀为重量级锁**

## 偏向锁

在大多数情况下，只有一个线程执行同步块，而轻量级锁的请求和释放需要消耗多次CAS。偏向锁的目的是使某个线程得到锁之后，就好像得到了这个锁的偏护，减少了锁的执行路径。所以偏向锁的释放只需要一次CAS来置换ThreadID，**当有多个线程同时请求偏向锁的时候，锁就会升级为重量级锁**

## 分段锁

ConcurrentHashMap就是一个例子

## 锁优化

* 细化锁粒度: 将大对象分离成小对象
* 锁分离: 例如ReadWriteLock，读写分离
* 锁消除: JIT发现对象不可能被共享，就会消除锁
* 锁粗化: 锁太细的化，就会导致程序过度的请求锁
* 减少锁持有的时间: 不给不需要加锁的程序加锁
