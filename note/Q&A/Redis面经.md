# Redis面经

### Redis有哪些数据结构

* **低级**: Hash, Set, String, SortedSet, List
* **中高级**: HyperLogLog, Pub/Sub, Geo
* **加分级**: Redis Module, BloomFilter, RedisSearch, Redis-ML

### 为什么使用Redis

现在主流的APP以及网站的高峰浏览量如果全部加在传统数据库上，那么很容易搞崩数据库，所以需要**缓存中间件**，市场上主流的有Memcached和Redis，但是一般用Redis，因为它更灵活，更可靠

### 什么是缓存穿透，BloomFilter如何避免缓存穿透

对于不存在的元素的大量请求砸在数据库上导致数据库崩溃

BloomFilter对于一个待查找的元素，可以立刻得出这个元素在不在数据库当中

### 如果有大量的key需要同一时间过期，那么应该注意什么

如果大量的key过期时间设置的过于集中，到过期的那个时间点，redis可能会出现短暂的卡顿现象。严重的话会出现缓存雪崩，我们一般需要在时间上加一个随机值，使得过期时间分散一些。

**电商首页经常会使用定时任务刷新缓存，可能大量的数据失效时间都十分集中，如果失效时间一样，又刚好在失效的时间点大量用户涌入，就有可能造成缓存雪崩**

### Redis分布式锁面对持有锁的机器的突然crash的情况该怎么办

setnx和expire，设置锁的同时防止锁忘记释放

### 假如Redis有1亿个key，其中有100w个key以固定的前缀开头，如何全部获取

keys指令可以扫描指定的key列表

### 如果正在线上的项目要实现上面一题的功能，如果还是采取同样的做法，会出现什么问题

由于redis是单线程的，keys执行会阻塞线程一段时间，scan指令可以无阻塞的实现keys的功能，但是可能会出现查询结果重复，可以在客户端去重一次，但是scan总体花费的时间会比keys要长

### Redis如何实现异步队列

使用list，利用rpush和lpop，当lpop没有消息的时候，sleep一段时间

**问:如果不允许sleep呢?**  **答:用阻塞方法blpop**

### Redis异步队列可不可以一次生产，多次消费

可以基于发布/订阅模式，即(pub/sub)

### Pub/Sub有什么缺点

Pub一方下线，生产的内容丢失，需要专业的消息队列RocketMQ

### Redis如何实现延时队列

* 利用sortedset，key为消息，score为时间戳
* zadd添加消息
* zrangebyscore来获得N秒之前的消息

### RDB原理

fork和cow，子进程创建RDB，父进程继续读写，采用Copy on Write方法

### 谈谈并发访问Redis会带来的问题，如何解决

**场景: A,B,C三个系统要操作一个Redis缓存中的同一个key，但是因为A的网络抖动问题，导致A,B,C三个的操作顺序发生了变化，这些顺序逻辑的变化可能会导致线上的项目出现致命的问题**

#### 如何解决这种问题?

ZooKeeper可以在解决这个问题当中扮演一个很好的角色，在学习ZooKeeper的时候我们知道，**ZooKeeper选举Leader可以通过同时向集群中写入同一个相同的节点，成功写入的那一个就成为了Leader**

那么这里可以采用相同的做法，**A,B,C三个系统可以通过获得对ZooKeeper分布式锁的占有来获取对Redis缓存的读写操作权限**

而在写入缓存的时候，**往往每次要往Redis中写入的数据都是从数据库中检索出来的数据**，要保持数据的最新性，每次检索出来的结果都应加上一个时间戳，和Redis缓存中的时间戳比对，如果是最新的，那么就写入缓存，如果不是最新的，那么就直接丢弃

### 只要同时存在缓存和数据库，就一定会存在缓存和数据的数据一致性问题，如何解决

很容易联想到MySQL中的事务隔离等级中的Serialization，当然，这是最容易想到，也是最卡性能瓶颈的方法，**将对缓存和数据库的操作全部都串行到一个FIFO队列当中**，对于缓存执行的操作同样也会施加到数据库当中，那么一定可以保持数据的一致性，那么问题就在于，对于高并发的项目来说，如果一个操作刚好阻塞，那么后面的全都阻塞了，正所谓**占着茅坑不拉屎**

### 你了解最经典的KV,DB读写模式吗

最经典的DB,KV读写模式就是**Cache Aside Pattern**

* **读数据的时候，先读缓存，缓存没有再读数据库，同时刷新到缓存当中**
* **更新数据的时候，首先更新数据库，然后删除缓存！！！！！**

点1很好理解，问题就在于点2，这也是一个关于性能的考虑，也体现了**懒加载**的模式，如果不采用这种方式，假定数据的更新很频繁，一分钟1000次更新，那么缓存也要更新1000次，但是如果这个缓存一分钟只被访问了一次呢?那么之前的更新操作是不是完全都没有意义，对于直接删除缓存，等到再用的时候再取，也只耗费了一次Query时间

### Redis的线程模型是什么

Redis采用了file event handler，由于这个handler是单线程的，所以Redis也是单线程的，但是Redis采用单线程的多路I/O复用来提升性能

其本质就是监听多个Socket，将不同的Socket产生的事件放置到队列中进行排队
