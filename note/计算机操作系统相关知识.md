## 计算机操作系统相关知识

> ### 存储板块

1. **常见的串行访问存储器**

```markdown
串行访问存储器是对存储单元进行读写的时候，需要按照其物理位置的先后顺序寻址
串行访问存储器包括“顺序存取存储器(磁带)”和“直接存取存储器(磁盘)”
```

2. **顺序存取存储器和直接存取存储器以及RAM之间的区别**

```markdown
顺序存取存储器只能按照顺序存取
RAM可以按照随机访问任何一个单元
直接存取存储器介于两者之间，寻取信息的时候先寻找整个存储器的某个小区域(例如磁道)，再在小区域内部查找
```

3. **什么是相联存储器？**

```markdown
其基本原理是把存储单元所存内容的某一部分作为检索项去检索该存储器，并将存储器中与该检索项符合的存储单元内容读出或者写入
```

4. **操作系统程序保存在哪里？**

```markdown
操作系统程序保存在硬盘上，首先要先将其引导到主存中，而引导程序通常放在ROM中
而程序运行时需要读写操作，因此应该采用RAM
```

5. **双端口RAM的读写冲突**

```markdown
双端口RAM并不是对同一个内存地址单元进行操作的时候都会发生冲突
1. A读取地址M，B写地址M，会冲突
2. A写地址M，B写地址M，会冲突
3. A读地址M，B读地址M，会冲突
```

6. **高位交叉编址和低位交叉编址谁更好的利用了局部性原理？**

```markdown
看起来高位交叉编址的存储器内容连续存放好像更加满足程序的局部性原理，但是其实是低位交叉编址更加满足！！！！！！
高位交叉编址并没有提高存储器的带宽，相反低位交叉编址虽然不连续，但是连续读取的带宽变大了，更像是为了满足程序局部性原理
而设计的产物
```

7. **有关低位交叉编址的误区！！！！**

```markdown
Pre: 假设一个四体低位交叉存储器，每个模块的容量是64K × 32位，存取周期为200ns，总线周期为50ns

说法：在50ns内，每个模块能向CPU提供32位信息？
分析：这种说法是错误的，是在200ns内，整个存储器能向CPU提供128位信息，但是每一个存储体仍然需要200ns才能向整个存储器提供32
	 位信息
```

8. **Cache写策略**

```markdown
1. Cache写命中的时候
	(1) 全写法：CPU将数据同时写回Cache和主存
	(2) 写回法：CPU只写入Cache不写入主存，等到换出Cache块的时候才写入主存，需要设置脏位
2. Cache写不命中的时候
	(1) 写分配法：加载主存中的块到Cache中，然后更新这个Cache，试图利用空间局部性，但是每一次不命中都要替换
	(2) 非写分配法：只写主存，不调块

非写分配法通常和全写法合用，写分配法通常和写回法合用
```

9. **加快地址转换的快表TLB**

```markdown
TLB是由高速缓冲存储器构成，其不是放在内存当中，而是放在专门的存储器
TLB的内容基本包含3个部分：Tag、Valid、实页号
```

10. **虚拟地址VA和物理地址PA之间的关系(重要)**

```markdown
//2018年王道真题
Q: 假设计算机按照字节编址，虚拟地址空间大小为16MB，物理地址大小为1MB，页面大小为4KB，Cache采用直接映射方式，共8行，主存
   和Cache之间交换的块大小为32B。判断虚拟地址位数，物理地址位数，虚页号位数，页框号位数，TLB中的tag位数，Cache中的Tag位数

1. 虚拟地址空间大小为16MB，因此虚拟地址位数为24位
2. 物理地址空间大小为1MB，因此物理地址位数为20位
3. 页面大小为4KB，即12位，因此VAP位数为24-12=12位，PAP位数为20-12=8位
4. PA为24位，页大小为4KB，因此TLB中的tag标记为共24-12=12位
5. PA的组成为：Tag,Index,Offset，其中块大小为32B，Offset共5位，直接映射共8行，Index共3位，故Tag=20-5-3=12位

补：若TLB还要组相联，还要从虚页号VAP中划分
```

11. **存取周期和存取时间**

```markdown
存取时间表示完成一次操作的时间，存取周期不仅包含操作时间还包含操作之后恢复线路的时间
存取周期=存取时间+恢复时间
```

12. **主存和Cache之间的调度是由硬件还是软件完成？**

```markdown
纯硬件
```

13. **用户源程序到内存中可执行程序的过程**

```markdown
1. 编译：将用户源代码编译成若干目标模块
2. 链接：将目标模块与所需的库函数链接在一起，形成完整的装入模块
3. 装入：将装入模块装入到内存中运行

(1) 在链接阶段
	a. 静态链接：程序运行之前，就链接成一个完整的模块，之后不再分开
	b. 装入时动态链接：装入内存时，边装入边链接
	c. 运行时动态链接：程序需要执行该目标模块时才链接。便于修改和更新，实现对目标模块的共享
(2) 在装入阶段
	a. 绝对装入：在“编译”时就知道程序将驻留内存的某个区域，“编译程序产生绝对地址的目标代码”，程序的逻辑地址与物理地址完全
	   相同
	b. 静态重定位装入：一个作业的地址由逻辑地址加上这个作业的起始地址，作业在装入的时候，必须分配它要求的全部内存空间，若没有
	   足够的内存，则不能装入这个作业。此外作业一旦进入内存，整个运行期间就不能在内存中移动，也不能再申请内存空间
	c. 动态重定位装入：程序装入内存时并不进行地址转换，而当运行时才进行地址转换，而且程序不需要被分配到连续的内存之中，还可以
	   根据需要动态申请分配内存。“这种方式需要一个重定位寄存器”
```

